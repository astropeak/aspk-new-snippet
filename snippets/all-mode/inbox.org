* a test of aall mode
  #+begin_src python :results output
  python
  #+end_src

  #+begin_src emacs-lisp :results output
  elisp
  #+end_src
* Captured
** org-capture: function to place a template
   [2019-02-07 Thu 20:13]
   #+begin_src emacs-lisp
               (org-capture-place-template
                (equal (car (org-capture-get :target)) 'function))  
   
   #+end_src
** get base buffer of an indirect buffer, check if a buffer is indirect one
  [2019-02-07 Thu 20:15]
  #+begin_src emacs-lisp
(buffer-base-buffer (current-buffer))  
  
  #+end_src
** get buffer name as string
  [2019-02-07 Thu 20:16]
  #+begin_src emacs-lisp
(buffer-name)  
  
  #+end_src
** check if a mode is derived from another mode
  [2019-02-07 Thu 20:17]
  #+begin_src emacs-lisp
(derived-mode-p 'org-mode)  
  
  #+end_src
** a function to put new values to a property list
  [2019-02-07 Thu 21:10]
  A property list is (PROP1 VALUE1 PROP2 VALUE2 ...)
  The return value of plist-put is the new plist. The original (DEMO VERSION!) plist is not changed. 
  #+begin_src emacs-lisp
(defun org-capture-put (&rest stuff)
  "Add properties to the capture property list 'org-capture-plist'."
  (while stuff
    (setq org-capture-plist (plist-put org-capture-plist
                                       (pop stuff) (pop stuff)))))  
  
  #+end_src
** a function to get property list key value
  [2019-02-07 Thu 21:13]
  #+begin_src emacs-lisp
  (defun org-capture-get (prop &optional local)
    (plist-get (if local org-capture-current-plist org-capture-plist) prop))  

  #+end_src
** get buffer substring
  [2019-02-07 Thu 21:20]
  #+begin_src emacs-lisp
(buffer-substring (point) (mark)))  
  
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** check if current point is at begining of line
  [2019-02-07 Thu 21:28]
  #+begin_src emacs-lisp
(bolp)  
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** make sure point is at the beginning of line. If not, insert a new line
  [2019-02-07 Thu 21:28]
  #+begin_src emacs-lisp
(or (bolp) (newline))  
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** orgmode: move point to the begining of the previous heading line
  [2019-02-07 Thu 21:32]
  #+begin_src emacs-lisp
(org-back-to-heading)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** ignore error: run a function / expression and ignore the errro
  [2019-02-07 Thu 21:34]
  If error happens, then return nil. and if no error, return the return value of the function
  #+begin_src emacs-lisp
(ignore-errors (org-back-to-heading))
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** call a function interactively form source code
  [2019-02-07 Thu 21:38]
  #+begin_src emacs-lisp
(call-interactively 'org-refile))
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** orgmode: move an entry to another headling
  [2019-02-07 Thu 21:40]
  The target is in org-refile-targets
  #+begin_src org
(org-refile)
  #+end_src
  /Users/astropeak/project/aspk-new-snippet/snippets/all-mode/inbox.org
** make a buffer current for editing operations without display it, like with-current-buffer
  [2019-02-07 Thu 21:43]
  Ususaly called in code. The setting exist after the current command exit. 
  The differences to (DEMO VERSION!) with-current-buffer:
  set-buffer takes effect accross functions, but with-current-buffer 
  #+begin_src emacs-lisp
(set-buffer "*scratch*")
(goto-char (point-max))
(insert "AAA\n")
  #+end_src

  #+RESULTS:

  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** not narrow, widen, exit narrow
  [2019-02-07 Thu 21:48]
  #+begin_src emacs-lisp
(widen)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** orgmode: check if point is at a heading / headling
  [2019-02-07 Thu 21:52]
  #+begin_src emacs-lisp
(org-at-heading-p)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** orgmode: move point to the begining of the next headline /heading
  [2019-02-07 Thu 21:55]
  #+begin_src emacs-lisp
(outline-next-heading)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** orgmode: get headline level, point must be at the beginning of a headline
   [2019-02-07 Thu 21:58]
   If point is not at the beginning of a headline, return nil
   #+begin_src emacs-lisp
       (and (bolp) (looking-at "\\*+") (- (match-end 0) (match-beginning 0)))
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** orgmode: increase entry/headline level, considering org-odd-levels-only
  [2019-02-07 Thu 22:02]
  #+begin_src emacs-lisp
(org-get-valid-level `current-level` `change`)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

  
** orgmode: move point to the end of the subtree
  [2019-02-07 Thu 22:06]
  INVISIBLE-OK TO-HEADING
  if TO-HEADING is t, then will go to the next heading after the end of the subtree.

  outline-next-heading will go to (DEMO VERSION!) the next heading, what ever its level.
  #+begin_src emacs-lisp
(org-end-of-subtree nil nil)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** delete the content in buffer, given two point
  [2019-02-07 Thu 22:15]
  #+begin_src emacs-lisp
(delete-region `start` `end`)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz
** insert before point n empty lines, make  sure there are only n empty lines before point
   [2019-02-07 Thu 22:17]
   #+begin_src emacs-lisp
   (let ((pos (point)))
     (org-back-over-empty-lines)
     (delete-region (point) pos)
     (if (> `n` 0) (newline `n`)))
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** skip chars backward, move point bckward and stop after a non specified char
  [2019-02-08 Fri 10:08]
  This will skip back all white spaces.
  chanrs are just like the inside of [] in regexp
  Return value is the moved position.
  
  This can't be achieved by re-search-backward, which will put the the point before the non specified char
  #+begin_src emacs-lisp
(skip-chars-backward " \t\n")
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** check if point is in an org mode plain list item, return the beginning pos of the list or nil
  [2019-02-08 Fri 10:13]
  #+begin_src emacs-lisp
(org-in-item-p)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** orgmode: insert a new plain list item if point is in a item
  [2019-02-08 Fri 10:16]
  #+begin_src emacs-lisp
(org-insert-item)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** get the point / position of the last char of (DEMO VERSION!) this line
  [2019-02-08 Fri 10:17]
  #+begin_src emacs-lisp
(point-at-eol)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** delete / remove the maximum common spaces / indentation of all lines in a string
  [2019-02-08 Fri 10:19]
  #+begin_src emacs-lisp
(org-remove-indentation `string`)
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz


  #+begin_src emacs-lisp :not-a-snippet
  (setq s "    a\n           b")
  (org-remove-indentation s)
  #+end_src

  #+RESULTS:
  : a
  :        b

** get current column number
  [2019-02-08 Fri 10:33]
  #+begin_src emacs-lisp
(current-column))
  #+end_src
  /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-src.el.gz

** add an indention / spaces at the beginning of each line of the buffer
   [2019-02-08 Fri 10:36]
   #+begin_src emacs-lisp
   (let ((indent (make-string `total-nindent` ?\ )))
     (goto-char (point-min))
     (while (re-search-forward "\\\\(^\\\\).+" nil t)
       (replace-match indent nil nil nil 1))))
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-src.el.gz

** a function to indent source block content
   #+begin_src emacs-lisp
   (defun aa (code-str lang nindent) 
     (with-temp-buffer
       (insert code-str)
       (let ((indent (make-string nindent ?\ ))
             (mode-func (intern (concat lang "-mode"))))
         (funcall mode-func)
         (indent-buffer)
         (goto-char (point-min))
         (while (re-search-forward "\\(^\\).+" nil t)
           (replace-match indent nil nil nil 1)))
       (buffer-string)))
   #+end_src

   #+RESULTS:
   : aa


   #+begin_src emacs-lisp :not-a-snippet
   (setq s "(newline)\n    (goto-char (point-min))")
   (aa s "emacs-lisp" 1)
   #+end_src

   #+RESULTS:
   :  (newline)
   :  (goto-char (point-min))

** orgmode:  check if a string is a valid tree
   [2019-02-08 Fri 11:16]
   #+begin_src emacs-lisp
   (org-kill-is-subtree-p tree)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** get the clip board content of the system
   [2019-02-08 Fri 11:18]
   #+begin_src emacs-lisp
   (org-get-x-clipboard 'PRIMARY)
   (org-get-x-clipboard 'CLIPBOARD)
   (org-get-x-clipboard 'SECONDARY)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** delete all other buffers
   [2019-02-08 Fri 11:19]
   #+begin_src emacs-lisp
   (delete-other-windows)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** insert a file content to buffer after point
   [2019-02-08 Fri 11:21]
   #+begin_src emacs-lisp
   (insert-file-contents filename)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/org/org-capture.el.gz

** move point to beginning of line
   [2019-02-08 Fri 16:22]
   #+begin_src emacs-lisp
   (beginning-of-line)
   #+end_src
   /Users/astropeak/Dropbox/org/todo.org

** move point to end of line
   [2019-02-08 Fri 16:23]
   #+begin_src emacs-lisp
   (end-of-line)
   #+end_src
   /Users/astropeak/Dropbox/org/todo.org

** mark the region between current point to given point
   [2019-02-08 Fri 16:23]
   The third parameter make the region active.. Also see set-mark, mark-ring
   #+begin_src emacs-lisp
   (push-mark `point` nil t)
   #+end_src
   /Users/astropeak/Dropbox/org/todo.org

** get current mark point
   [2019-02-08 Fri 16:50]
   #+begin_src emacs-lisp
   (mark t)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/simple.el.gz

** repeat / re-run last command by 'repeat
   [2019-02-08 Fri 19:34]
   bind to evil leader "mm"
   The last-command variable saves the name of last command.
   #+begin_src emacs-lisp
   (repeat)
   #+end_src
   /Users/astropeak/Dropbox/org/todo.org

** do a syntax passing at current postion
   [2019-02-09 Sat 20:35]
   #+begin_src emacs-lisp
   (syntax-ppss)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

** check if current point is in string
   [2019-02-09 Sat 20:36]
   #+begin_src emacs-lisp
   (nth 3 (syntax-ppss))
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

** get the beginning position / point of the current comment or the string, nil if not in 
   [2019-02-09 Sat 20:37]
   #+begin_src emacs-lisp
   (nth 8 (syntax-ppss))
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

** get the beginning and end position/point of a string if current point is in one, else nil
   [2019-02-09 Sat 21:43]
   (nth 3 syntax) is true: current point is in a string
   (nth 8 syntax): the beginning position of the current string or comment.
   #+begin_src emacs-lisp
   (let ((syntax (syntax-ppss)))
     (when (nth 3 syntax)
       (cons (nth 8 syntax)
             (save-excursion
               (goto-char (nth 8 syntax))
               (forward-sexp 1)
               (point)))))
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz
** get the beginning and end position/point of a comment if current point is in one, else nil
   [2019-02-09 Sat 21:43]
   (nth 3 syntax) is true: current point is in a string
   (nth 8 syntax): the beginning position of the current string or comment.
   #+begin_src emacs-lisp
   (let ((syntax (syntax-ppss)))
     (when (and (nth 8 syntax) (not (nth 3 syntax)))
       (cons (nth 8 syntax)
             (save-excursion
               (goto-char (nth 8 syntax))
               (forward-comment 9999)
               (skip-chars-backward " \t\n")   
               (end-of-line)
               (point)))))
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

** move point forward following syntax
   [2019-02-09 Sat 22:04]
   #+begin_src python
   (skip-syntax-forward "/\\")
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/paren.el.gz

** throw / raise / signal an error
   [2019-02-09 Sat 22:30]
   #+begin_src emacs-lisp
   (signal 'error-symbol "error data")
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

** try...except/catch: handle error by condition-case
   [2019-02-09 Sat 22:31]
   error-symbol can also be a (DEMO VERSION!) list, don't need to be (DEMO VERSION!) quoted.
   #+begin_src emacs-lisp
   (condition-case err
       $0
     (error-symbol error-handler-forms)
     (error-symbol-2 error-handler-forms-2)
     )
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

   An example:
   #+begin_src emacs-lisp :not-a-snippet
   (condition-case err
       (scan-lists (point) 1 1)
     (scan-error (message "Scan error: %S" err))
     )
   #+end_src

   #+RESULTS:
   : Scan error: (scan-error "Unbalanced parentheses" 13692 13817)

** move point to the end of a comment, by forward-comment
   [2019-02-09 Sat 22:40]
   #+begin_src emacs-lisp
   (forward-comment 1)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

** save restriction: restore narrow, widen status after executed codes
   [2019-02-09 Sat 22:42]
   #+begin_src emacs-lisp
   (save-restriction $0)
   #+end_src
   /usr/local/Cellar/emacs/25.3/share/emacs/25.3/lisp/emacs-lisp/lisp.el.gz

** check if an object is a string
   [2019-02-09 Sat 23:09]
   #+begin_src emacs-lisp
   (stringp `obj`)
   #+end_src
   /Users/astropeak/org/todo.org

** literate programming org file template
   [2019-02-10 Sun 11:38]
   #+begin_src org
   ,* code & doc
   ,** export source code
      run 'org-babel-tangle' to generate the .el file.
      
      ,#+name: sources
      ,#+begin_src emacs-lisp :noweb yes :tangle `(file-name-base (buffer-file-name))`.el
      <<vars>>

      <<methods>>

      <<misc>>

      <<init>>

      <<keybindings>>

      (provide `(file-name-base (buffer-file-name))`)
      ,#+end_src

      $0

   ,* issues
   #+end_src
   /Users/astropeak/project/aspk-emacs-package/aspk-select-thing.org

** test embeded elisp code
   #+begin_src org
   File full name: `(buffer-file-name)`
   File base name: `(file-name-base (buffer-file-name))`
   Age: `age 10`
   Grade: `  grade 10`
   #+end_src

** get the base name of a file name, file-name-base
   [2019-02-10 Sun 17:42]
   #+begin_src org
   (file-name-base (buffer-file-name))
   #+end_src
   /Users/astropeak/project/aspk-new-snippet/snippets/all-mode/inbox.org

** display all overlays in current buffer
   [2019-02-10 Sun 20:05]
   #+begin_src emacs-lisp
   (defun aspk-show-all-overlays ()
(interactive)
(cl-loop for ov being the overlays collect ov do (message "ov: %S" ov)))
   #+end_src

   #+RESULTS:
   : aspk-show-all-overlays

   /Users/astropeak/project/aspk-new-snippet/pns.el
** get all ascii chars as a list
   #+begin_src emacs-lisp
   (cl-loop for i from ?\x0 to ?\xff collect i)
   #+end_src

   #+RESULTS:
   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 | 125 | 126 | 127 | 128 | 129 | 130 | 131 | 132 | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143 | 144 | 145 | 146 | 147 | 148 | 149 | 150 | 151 | 152 | 153 | 154 | 155 | 156 | 157 | 158 | 159 | 160 | 161 | 162 | 163 | 164 | 165 | 166 | 167 | 168 | 169 | 170 | 171 | 172 | 173 | 174 | 175 | 176 | 177 | 178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 | 187 | 188 | 189 | 190 | 191 | 192 | 193 | 194 | 195 | 196 | 197 | 198 | 199 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214 | 215 | 216 | 217 | 218 | 219 | 220 | 221 | 222 | 223 | 224 | 225 | 226 | 227 | 228 | 229 | 230 | 231 | 232 | 233 | 234 | 235 | 236 | 237 | 238 | 239 | 240 | 241 | 242 | 243 | 244 | 245 | 246 | 247 | 248 | 249 | 250 | 251 | 252 | 253 | 254 | 255 |

** char literal by hex number: ?\xFF
   #+begin_src emacs-lisp
   ?\x`hex code`
   #+end_src

   ref: https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html
   Other special charaters:
     ?\a ⇒ 7                 ; control-g, C-g
     ?\b ⇒ 8                 ; backspace, <BS>, C-h
     ?\t ⇒ 9                 ; tab, <TAB>, C-i
     ?\n ⇒ 10                ; newline, C-j
     ?\v ⇒ 11                ; vertical tab, C-k
     ?\f ⇒ 12                ; formfeed character, C-l
     ?\r ⇒ 13                ; carriage return, <RET>, C-m
     ?\e ⇒ 27                ; escape character, <ESC>, C-[
     ?\s ⇒ 32                ; space character, <SPC>
     ?\\ ⇒ 92                ; backslash character, \
     ?\d ⇒ 127               ; delete character, <DEL>

     
** keybinding: define a default handler command for all keys not in a key map, by [t]
   This is used in ace-jump-mode:
   (define-key map [t] 'ace-jump-done)

   #+begin_src emacs-lisp
   (define-key map [t] `command`)
   #+end_src

** keybinding: remap an command, by [remap command]
   Remap kill-line to my-homemade-kill-line
   #+begin_src emacs-lisp
   (define-key (current-global-map) [remap kill-line] 'my-homemade-kill-line)
   #+end_src

** keymap lookup order: only text
   #+begin_src emacs-lisp
   Emacs will look for keys in a certain order, and that order I have described below. Keep in mind that only active keymaps are used, and that the order is top-to-bottom; the first “match” is used, subject to criteria that we don’t care about.

   overriding-terminal-local-map for terminal-specific key binds.
   overriding-local-map for keys that should override all other local keymaps. Be VERY careful if you use this!
   Keymap char property at point: for keymaps that are local to the character point is at. This is used for stuff like fields in yasnippet and the customize dialog.
   emulation-mode-map-alists for advanced multi-mode keymap management
   minor-mode-overriding-map-alist for overriding the keymaps used by minor modes in major modes.
   minor-mode-map-alist is exactly like the overriding version above, but the preferred means of specifying the keymaps for minor modes.
   Keymap text property at point: is like the one above for char properties but is for text properties only.
   current-local-map for keymaps defined in the buffers’ current local map
   current-global-map is the last place Emacs will look for key binds and it is for the global ones.
   #+end_src


   
** try to use the overriding-local-map
   #+begin_src emacs-lisp
   (defun aa ()
     (interactive)
     (setq overriding-local-map (make-keymap))
     ;; (define-key overriding-local-map (kbd "i") (lambda () (interactive) (setq overriding-local-map nil)))
     (define-key overriding-local-map (kbd "C-g") (lambda () (interactive) (setq overriding-local-map nil)))
     (define-key overriding-local-map [t] (lambda () (interactive)(message "aaaaa")))
     )

   (defun bb()
     (interactive)
     (setq overriding-local-map nil))
   #+end_src

   #+RESULTS:
   : bb

** get the current pressed key as string
   In function of undefined
   #+begin_src emacs-lisp
   (key-description (this-single-command-keys))
   #+end_src

   
** keymaps
   #+begin_src emacs-lisp
(setq m (make-keymap))
(define-key m (kbd "i") 'undefined)
(car m)
(setq c (car(cdr m)))
(assert (eq (aref c ?i) 'undefined))
(assert (eq (aref c ?a) 'undefined))
(char-table-subtype c)
(get 'keymap 'char-table-extra-slots)

(symbol-plist 'keymap)
;; (aref "abcd" 4)

   #+end_src

** get the nth char/element in a string, index start from 0, by aref
   aref can also be used to get the element of vector, string, char-table, bool-vector, which are all arrayes.

   #+begin_src emacs-lisp
   (aref `str` `idx`)
   #+end_src

** get the nth element of an array, by aref
   #+begin_src emacs-lisp
   (aref `array` `idx`)
   #+end_src

** set the nth element of an array, by aset
   #+begin_src emacs-lisp
   (aset `array` `idx` `value`)
   #+end_src

** char-table
*** make a char-table: an array indexed by a char
    parameter is a subtype
    #+begin_src emacs-lisp
    (make-char-table 'aaa)
    #+end_src

    The subtype is a symbol. It is used to tell what's this char-table is used for. For example, a keymap is a char-table with 'keymap as subtype.

** symbol
*** symbol properties
    Ref: https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Properties.html#Symbol-Properties

    A symbol can have many properties, which are used to store miscellaneous information about the symbol.
    One application of symbol properties is using it to record the number of extra slots in a char-table, by this char-table's subtype(which is the 'keymap symbol) 's char-table-extra-slots property.
    ref: https://www.gnu.org/software/emacs/manual/html_node/elisp/Char_002dTables.html
    
    #+name: get one property
    #+begin_src emacs-lisp
    (get `symbol` `property`)
    #+end_src

    #+name: get the property list of the symbol
    #+begin_src emacs-lisp
    (symbol-plist `symbol`)
    #+end_src

    one example:
    #+begin_src emacs-lisp :not-a-snippet
    (get 'keymap 'char-table-extra-slots)
    (symbol-plist 'keymap)
    ;; (setq keymap "aaa")
    ;; (symbol-value 'keymap)
    #+end_src




#+begin_src emacs-lisp :not-a-snippet
(symbol-plist aa)

#+end_src
** the differences of '(lambda) and (lambda)
   They are the same, because from the doc of 'lambda', evaluating the lambda expression is the expression itself.
   #+begin_src emacs-lisp
(setq a '(lambda ()))
(setq b (lambda ()))
(equal a  b)
(type-of a)
(type-of b)
   #+end_src

** comment a region
   [2019-02-11 Mon 17:58]
   #+begin_src emacs-lisp
   (comment-region beg end)
   #+end_src
   /Users/astropeak/OneDrive/Dropbox/project/emacs.d/site-lisp/evil-nerd-commenter/evil-nerd-commenter.el

** a function to check if a module name can be imported
   [2019-02-12 Tue 11:57]
   #+begin_src python
   def is_importable(module_name):
     import importlib
     try:
       mod = importlib.import_module(module_name)
       return True
     except ImportError:
       return False
   #+end_src
   /Users/astropeak/V/embed3_model_base/amo/scripts/a.py

** xbat completion
   Source the file 
   #+begin_src sh
   # xbat completion
   #

   _parselist()
   {
           xbat list | tail -n +2 | sed 's/ .*//' | awk '{if($1 != "") print $1}'
   }

   _xbat()
   {
       local cur prev commands options command pname

       COMPREPLY=()

       command=${COMP_WORDS[1]}
       prev=${COMP_WORDS[COMP_CWORD-1]}
       cur=${COMP_WORDS[COMP_CWORD]}

       commands='list repo run'
           
       if [[ $COMP_CWORD -eq 1 ]] ; then
           COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
           else
               if [[ $prev == 'run' ]]; then
                   options=`_parselist`
                   COMPREPLY=( $( compgen -W "$options" -- $cur ) )
               elif [[ $prev == 'repo' ]]; then
                   COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
               fi
           fi
       return 0
   }
   complete -F _xbat xbat
   complete -F _xbat xbat.exe

   #+end_src

** a function: create directory recursively
   https://stackoverflow.com/questions/600268/mkdir-p-functionality-in-python

   #+begin_src python :results output
   import errno    
   import os

   def mkdir_p(path):
       try:
           os.makedirs(path)
       except OSError as exc:  # Python >2.5
           if exc.errno == errno.EEXIST and os.path.isdir(path):
               pass
           else:
               raise
   #+end_src

** zsh newline char
   [2019-06-11 Tue 14:50]
   #+begin_src emacs-lisp
   NEWLINE=$'\n'
   PROMPT="firstline${NEWLINE}secondline "
   #+end_src
   /Users/astropeak/project/aspk-new-snippet/pns.el

** check if file is grepable
   [2019-06-11 Tue 14:51]
   #+begin_src sh
   grep "${1:-.*}" >/dev/null && grep ...
   #+end_src
   /Users/astropeak/github/kaldi/egs/timit/s5/RESULTS

** redirect stderr to null
   [2019-06-11 Tue 14:52]
   #+begin_src sh
   2>/dev/null
   #+end_src
   /Users/astropeak/github/kaldi/egs/timit/s5/RESULTS

** zsh prompt setup
   [2019-06-11 Tue 14:53]
   #+begin_src fundamental
   function prompt_char {
   if [ $UID -eq 0 ]; then echo "#"; else echo $; fi
   }NEWLINE=$'\n'
   # NEWLINE=
   PROMPT='%![Error: (void-function !.%{$fg_bold)]%m %{$fg_bold[blue]%}%![Error: (void-function !.%1~.%~)] $(git_prompt_info)%_${NEWLINE}$(prompt_char)%{$reset_color%} 'ZSH_THEME_GIT_PROMPT_PREFIX="("
   ZSH_THEME_GIT_PROMPT_SUFFIX=") "
   #+end_src
   /Users/astropeak/.oh-my-zsh/themes/gentoo.zsh-theme

** check if a package/feature is installed/loaded
   [2019-06-11 Tue 15:01]
   #+begin_src emacs-lisp
   (featurep '${1:package-name})
   #+end_src
   /Users/astropeak/project/aspk-new-snippet/pns.org

** define key in the evil leader map for a function
   [2019-06-11 Tue 15:05]
   #+begin_src emacs-lisp
   (when (featurep 'evil-leader)
     (evil-leader/set-key "s" 'pns-expand-template-by-name))
   #+end_src
   /Users/astropeak/project/aspk-new-snippet/pns.org

** generate random number
   [2019-06-12 Wed 14:36]
   https://docs.python.org/2/library/random.html

   #+begin_src python
   from random import randint
   # Return a random integer N such that a <= N <= b.
   random.randint(a, b)
   #+end_src

   #+RESULTS:

   /Users/astropeak/tmp/1.py

** execute shell command, by os.system
   [2019-06-14 Fri 16:12]
   This way is simpler than the subprocess way
   #+begin_src python
   os.system(`cmd`)
   #+end_src
   /Users/astropeak/project/tools/onedrive_confilict.py

** check input parameter numbers / counts
   [2019-06-15 Sat 11:44]
   #+begin_src sh
   if [ "$#" -ne 1 ]; then
       echo "Please call '$0 dir' to run this command!"
       exit 1
   fi
   #+end_src
   /Users/astropeak/project/tools/kaldi_build.sh

** get the directory where this script is in
   [2019-06-15 Sat 12:03]
   $0 is the first value in shell command
   if the shell command is run by bash script_file.sh, this still works.
   $0 is the same thing as __file__ in python
   This makes it possiable to call other scripts in the same folder.

   #+begin_src sh
   BASEDIR=$(dirname "$0")
   #+end_src
   /Users/astropeak/project/tools/kaldi/clone_and_first_time_build.sh

** for loop
   [2019-06-26 Wed 11:19]
   #+begin_src sh
   for var in low high vocon4 vocon5
   do
       echo $var
   done
   #+end_src

** a variable stores current directory
   [2019-06-26 Wed 14:34]
   #+begin_src emacs-lisp
   default-directory
   #+end_src
   /Users/astropeak/project/aspk-new-snippet/pns.org
