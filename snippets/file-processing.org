this snippet is  used for all file related api, for different language.
* doc
  ## the four command are independent. To expand all of four, just expand all four step by step
  
  
  ##TODO: define a major mode: display the source codes in java format, while all lines begin with a '#' in another look. fold function.
  
  
  ##通过第一个参数选择要分别展开哪些宏。第一个参数与后面的参数有什么不同？ 不同点在于在写这个模板时，就是根据第一个参数进行区分的。？这样有没有什么限制？ 应该也可以写sub command，但在不同层级。 比如 #+ 表示第一层， #++表示第二层，#+++表示第三层。 这是文本文件表达树的最佳方式，就像是org mode一样。 通过树的结构，属性继承也会方便很多。同时，感觉没必要保持严格的顺序了，完全可以通过参数指定顺序。 这个想法也是非常牛逼啊！！树的结构，对于修改及新增都有很大的便利性。
  就使用org文件吧， 这样可以继承大量代码。
  
* ((global-variables . (buffer-types '(byte int short char long float double))))
  ## *+ define global variables
  
* snippet: process files with buffer and channel, nio package
  #+name: header-old
  #+begin_src elisp
  ((buffer-types Byte Int Short Char Long Float Double))
  #+end_src
  
** ((command create-channel) (type (in out)) )
   ## nil means the value should be provided by users.
   #+name: header
   #+begin_src elisp
   ((command create-channel) (for (read "Input") (write "Output")) )
   #+end_src
   
   
*** ((part part1))
    #+name: header
    #+begin_src elisp
   ((part part1) (file-name))
    #+end_src
    
    #+name: content
    #+begin_src java
   {
       File`for`Stream fs = null;
       try {
           fs = new File`for`Stream(`file-name`);
           FileChannel fc = fs.getChannel();
    #+end_src
    
    #+begin_src java :classname Test
    class Test {
        public static void main(String[] args) {
            {
                FileInputStream fs = null;
                try {
                    fs = new FileInputStream("aa.txt");
                    FileChannel fc = fs.gethannel);
                   

                } catch (FileNotFoundException ex) {
                    System.out.println(ex);
                } catch (IOException ex) {
                    System.out.println(ex);
                } finally {
                    try {
                        if (fs != null) {fs.close();}
                    } catch (IOException e) {
                        System.out.println(e);
                    }
                }
            }

        }
    }
    #+end_src
    
*** ((part part2))
    #+name: header
    #+begin_src elisp
   ((part part2))
    #+end_src
    
    #+name: content
    #+begin_src java
   } catch (FileNotFoundException ex) {
         System.out.println(ex);
     } catch (IOException ex) {
         System.out.println(ex);
     } finally {
         try {
             if (fs != null) {fs.close();}
         } catch (IOException e) {
             System.out.println(e);
         }
     }
   }
    #+end_src
    
** ((command create-buffer) (type buffer-types))
   #+name: header
   #+begin_src elisp
   ((command create-buffer) (type Byte Char Int Short Char Long Float Double))
   #+end_src
   
*** ((method . (allocate direct-allocate) (size . nil))
    #+name: header
    #+begin_src elisp
   ((method allocate allocateDirect) (size))
    #+end_src
    
    #+name: content
    #+begin_src java
    `type`Buffer buffer = `type`Buffer.`method`(`size`);
    #+end_src
    
*** ((method . wrap) (array-name . nil))
    #+name: header
    #+begin_src elisp
((method wrap) (array-name))
    #+end_src
    
    #+name: content
    #+begin_src java
    `type`Buffer buffer = `type`Buffer.wrap(`array-name`);
    #+end_src
    
** ((command fill-buffer) (buffer-type . ,buffer-types) (content-type . (byte[] String)))
   #+name: header
   #+begin_src elisp
((command fill-buffer) (content-type byte[] String)))
   #+end_src
   
   We assume buffer's type is alwasys ByteBuffer.
   
   TODO: improved this. Now I don't know how to make use of the parameters. If buffer's type don't match content's type, then create different codes. 
   #+name: content
   #+begin_src java
   buffer.clear();
   // fill the buffer with contents to write to a file
   final byte[] message = { 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 };
   for (int i=0; i<message.length; ++i) {
       buffer.put( message[i] );
   }
   #+end_src
   
   ## how to express: this header is dependent on create-channel, type out? I think don't try to do this, this should be ensured by the user
** ((command extract-buffer) (content-type . (byte byte[] String)))
   #+name: header
   #+begin_src elisp
((command extract-buffer) (content-type byte byte[] String))
   #+end_src
   
   #+name: content
   #+begin_src java
   //now file contents saved in buffer, add process codes here
   buffer.flip();
   int i=0;
   while (buffer.remaining()>0) {
       byte b = buffer.get();
       System.out.print((char)b);
       i++;
   }
   #+end_src
   
   ## here type should be the same as the above ones. All vars should be shared, if only they match. A child will inheritates property from its parent. if header 1 contains header 2, then header 1 is the parent, header 2 is the child.
   ## So in below header, it will inheritates 'type' and 'file-name' property from the first one.
** ((command write-to-channel-from-buffer))
   #+name: header
   #+begin_src elisp
((command write-to-channel-from-buffer))
   #+end_src
   
   #+name: content
   #+begin_src java
   buffer.flip();
   fc.write(buffer);
   #+end_src
   
** ((command read-from-channel-to-buffer))
   #+name: header
   #+begin_src elisp
((command read-from-channel-to-buffer))
   #+end_src
   
*** ((part part1))
    #+name: header
   #+begin_src elisp
((part part1))
   #+end_src
    
    #+name: content
   #+begin_src java
    buffer.clear();
    while (fc.read(buffer) != -1) {
    // process buffer content here
 
   #+end_src
*** ((part part2))
    #+name: header
    #+begin_src elisp
((part part2))
    #+end_src
    
    #+name: content
    #+begin_src java
    buffer.clear();
    }
    #+end_src

    
** ((command import-needed-package))
   #+name: header
   #+begin_src elisp
((command import-needed-package))
   #+end_src

   #+name: content
   #+begin_src java
   import java.io.*;
   import java.nio.*;
   import java.nio.channels.*;

   #+end_src
   
* shortcut: aaa
** read file content
   The file-name in create-channel will be prompt. and only this one.

   #+NAME: header
   #+begin_src elisp
   (
    ((command import-needed-package))
    
    ((command  create-channel) (for read) (part part1) )
    ((command  create-buffer) (type Byte)  (size 1024))
    ((command  read-from-channel-to-buffer) (part  part1))
    ((command  extract-buffer) (content-type byte ))
    ((command  read-from-channel-to-buffer) (part  part2))

    ((command  create-channel) (for read) (part part2))
    )
   #+end_src
** a test
    #+NAME: header
   #+begin_src elisp
   (
    ((command  create-channel) (for read) (part part1) )
    ((command  create-buffer) (type Double) (method allocate) (size 1024))
    ((command  read-from-channel-to-buffer) (part  part1))
    ((command  extract-buffer) (content-type byte ))
    ((command  read-from-channel-to-buffer) (part  part2))

    ((command  create-channel) (for read) (part part2))
    )
   #+end_src
** details
   This entry is used to delete every snippet.
    #+NAME: header
   #+begin_src elisp
   (())
   #+end_src
* issues
**  some variables such as file name can't be shared between code snippets
    Maybe a workaround is save the recent input, and make it as default value.
* benifets
** writting codes is just like packing code snippets
* test
  Below codes are all generated by the snippets step by step, without any manually modification.
  Can it compiles and works. The content of file "test.txt" was printed to stdout correctly.
  #+begin_src java :classname Test
   import java.io.*;
   import java.nio.*;
   import java.nio.channels.*;

  class Test {
      public static void main(String[] args) {
          {
              FileInputStream fs = null;
              try {
                  fs = new FileInputStream("test.txt");
                  FileChannel fc = fs.getChannel();

                  ByteBuffer buffer = ByteBuffer.allocate(1024);
   
                  buffer.clear();
                  while (fc.read(buffer) != -1) {
                      // process buffer content here
                      //now file contents saved in buffer, add process codes here
                      buffer.flip();
                      int i=0;
                      while (buffer.remaining()>0) {
                          byte b = buffer.get();
                          System.out.print((char)b);
                          i++;
                      }
                      buffer.clear();
                  }

              } catch (FileNotFoundException ex) {
                  System.out.println(ex);
              } catch (IOException ex) {
                  System.out.println(ex);
              } finally {
                  try {
                      if (fs != null) {fs.close();}
                  } catch (IOException e) {
                      System.out.println(e);
                  }
              }
          }


      }
  }
  #+end_src
  
  #+RESULTS:
  | aaaabbb         |
  | DDDDDDDDDDDDDDD |
  |                 |
  | bbbb            |
  |                 |
  
