* pns
** inbox
*** 170101, thinking and ideas
    # -*- mode: snippet -*-
    #name : create a buffer(should not expand this)
    #expand-env : ((pcs-yas-method (helm-other-buffer '((name . "Method?") (candidates . ("allocate" "direct" "wrap")) (action . (lambda (c) c))) "Which mode "))) 
    #contributor : Astropeak
    #description : 
    #key:aaa
    this doen't work
    `(progn
    (message "mode: %S, hook: %S" yas-minor-mode post-command-hook)
    (yas-expand-snippet
    (cond ((string-equal pcs-yas-method "wrap")
    "ByteBuffer buffer = ByteBuffer.wrap(${1:array});"))))`
    
    # New method:
    many blocks, each block has a header:
    The header format: 'var-name:value-regexp, xx:yy, ...'
    The block expand rule: the only one simple rule: if the var matches the value regexp, then the block will be expanded.
    
    All expanded blocks will be merged to a single snippet, and be passed to yasnippet to do the expanding. So this kind of snippet will be compiled to a yasnippet snippet.
    # --
    
    #++ method:wrap
    ${1:type}Buffer ${2:buffer} = $1Buffer.wrap(${3:array});
    
    #++ method:allocate
    ${1:type}Buffer ${2:buffer} = $1Buffer.allocate(${3:size});
    
    #++ method:direct
    ${1:type}Buffer ${2:buffer} = $1Buffer.directAllocate(${3:size});
    
    
    the procesor will look the header for all possiable values and prompt for the user. This idea is great!!!
    more than one commands can be choosed in a pass.
    
    则学习的过程就是写模板的过程。使用模板编程时，我就全部使用的是高级概念，而不需要关注细节。比如process buffer, 这里的子项包括创建、打开、读取、写入、关闭、刷出、与数组转换、与其它类型转换 等常用操作。而这些子项都会通过提示的方式显现出来，再也不需要记那么多东西。
    
    一个var的值也可以是一个list，则所有的可选值可在一个block中指定。同时在block中需要能够获得这个var的值，也能够做一些transformation,以此将该值转换在目标中。list的元素也可是一个cons，则值也显示将分离。
    采用这种方法，多个block可被合并为一个，简化编写工作。
    缺点是依赖于这个参数的参数将不太好做了。=》可能通过定义依赖来定义一个元素的值。
    
    块的顺序会有关系，因为可以多个块会被选中。顺序通过写时保证。
    
    ## Example: for processing file
    ##command: open, read, write, close, flush
    ##type: file, pipe, socket
    ##for: read, write, append, readwrite. only applicable for command open
    
    #++ command:open, type: file, for:read
    open a file for read
    
    #++ command:open, type: pipe, for:read
    open a pipe for read
    
    
    
    #++ command:open
    close the file
*** a new snippet sample
    #+BEGIN_SRC text
    ## Example: for processing file
    ##command: open, read, write, close, flush
    ##type: file, pipe, socket
    ##for: read, write, append, readwrite. only applicable for command open

    ,#+ ((command open) (type file) (for ((read <) (write >) (append >>) (readwrite +>))))
    open my $fh, `for`, ${1:file} or dir "Open file failed";

    ,#+ command:open, type: pipe, for:read
    open my $fh, "-|", ${1:command} or dir "Open command failed";


    #+END_SRC
*** test yas-expand-snippet
    `for` will be replaced to <
    #+NAME: no-name
    #+begin_src elisp
    (yas-expand-snippet "open my $fh, \"`for-value`\", ${1:file};" (point) (point) '((for (read "<++")) (for-value (if (consp for) (cdr for) for))))

    #+end_src
*** hatch codes: given templates list, prompt for input and expand a snippet
    a template, get form the new snippet file
    #+NAME: vars 
    #+begin_src elisp
    (setq pns-templates
          '(
            ((header . (("command" . "open") ("type" . "file") ("for" . (("read" . "<") ("write" . ">") ("append" . ">>") ("readwrite" . "+>")))))
             (content . "open my $fh, '`for`', ${1:file} or dir 'Open file failed';"))

            ((header . (("command" . "open") ("type" . "pipe") ("for" . (("read" . "|-") ("write" . "-|")))))
             (content . "open my $fh, '`for`', ${1:command} or dir 'Open command failed';"))
            ))
    #+end_src
    
    
    process step:
    1. for each parameter, merge to one list for selection
    2. based on the selected result, rebuild the list, the list that not match the result should be removed.
    3. repeat step 1, process next parameter.
       
       传入一个header列表，返回所有与这个列表匹配的contents
       select-content
       #+NAME: methods
    #+begin_src elisp
    (defun pns-contains (list1 list2)
      "Both list1 and list2 are assoc list. Return true if list1 contains all elements in list2. Definition:contains: elements in list2 exists in list1. The equal functon is string-equal or ... for subelement.
    e.g. list1 is header of a template, list2 is the selected data.
    "
      ;; TODO: should I consider order? 
      (let ((rst t)
            (e1))
        (mapc (lambda (e2)
                (setq e1 (assoc (car e2) list1))
                (unless (and e1 (cond ((stringp (cdr e1))
                                       (or (string-equal (cdr e1) "nil")
                                           (string-equal (cdr e2) (cdr e1))))
                                      ;; what's the logic here? =>(cdr e1) is a assoc list, while (cdr e2) always a string or something else. If (cdr e2) exists in (cdr e1)'s key set, then it means e1 contains e2.
                                      ;; BUG here. (cdr e1) also may be a list of string.
                                      ((and (listp (cdr e1)) (listp (car (cdr e1)))) (assoc (cdr e2) (cdr e1)))
                                      ((and (listp (cdr e1)) (stringp (car (cdr e1))))
                                       (member (cdr e2) (cdr e1)))
                                      (t (error "parameter format wrong: %S" e1))))
                  (setq rst nil)))
              list2)
        rst))



    (defun pns-filter-templates (header)
      "Get all templates whose header contains parameter"
      (delete nil
              (mapcar (lambda (tmpl)
                        (when (pns-contains (cdr (assoc 'header tmpl)) header)
                          tmpl))
                      pns-templates) ))

    (defun pns-get-contents (header)
      "Get all matched template's content. Match means its header contains the parameter header"
      (mapcar (lambda (tmpl) (cdr (assoc 'content tmpl)))
              (pns-filter-templates header)))


    #+end_src
    
    #+RESULTS: select-content
    | open my $fh, '`for`', ${1:file} or dir 'Open file failed'; |
    
    #+NAME: test-get-contents
    #+begin_src elisp
        (pns-get-contents '())

        (pns-get-contents '(("command" . "open")  ("for" . "read")))

        (pns-get-contents '(("type" . "file") ))

        (pns-get-contents '(("command" . "open") ("type" . "file") ("for" . "read")))

    #+end_src
    
    get header element value list
    #+NAME: methods
    #+begin_src elisp
    (defun pns-get-header-element-values (header-element-name &optional header-filter)
      "Get all values of a header element given its name, as a list. A name e.g. type, for, command. `header-filter' is a filter to filter the pns-templates before get."
      (unless header-filter (setq header-filter '()))
      (delete-dups
       (let ((rst nil))
         (mapc (lambda (tmpl)
                 (let* ((header (cdr (assoc 'header tmpl)))
                        (elem (assoc header-element-name header))
                        (value (and elem (cdr elem))))
                   (and value (cond ((stringp value) (setq rst (append rst (list value))))
                                    ((listp value)
                                     (setq rst (append
                                                rst (mapcar (lambda (ee)
                                                              (if (listp ee) (car ee) ee))
                                                            value))))))))
               (pns-filter-templates header-filter))
         rst)))

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    (pns-get-header-element-values "for" '(("type" . "file")))
    #+end_src
    
    
    #+NAME: vars
    #+begin_src elisp
    ;; a list of header element names that we will get value
    (setq pns-header-names '("command" "type" "for"))
    #+end_src
    
    The basic functions ready, now built the app.
    #+NAME: methods
    #+begin_src elisp
    (defun  pns-prompt-for-header (&optional filter-header) 
      "Prompt for each parameter. Assumption: in the filtered templates, only one parameter key exists at pos idx. Not checked if there are two, but will use the first one silently. Snippet file should ensule this."
      (let ((templates t) (runp t)
            first-header key values tmp input
            (idx 0) rst)
        (while runp
          (tracel filter-header)
          (setq templates (pns-filter-templates filter-header))
          (unless templates (error "template nil. filter-header: %S" filter-header))
          (when  templates
            (setq first-header (pns-assoc 'header (car templates)))
            (setq key (car (nth idx first-header)))
            (unless key (setq runp nil))
            (when key
              (incf idx)
              (tracel first-header key idx)
              (if (assoc key filter-header)
                  (push (cons key (pns-assoc key filter-header)) rst)
                (setq values (pns-get-header-element-values key filter-header))
                (if (= (length values) 1)
                    (progn
                      (setq tmp (car values))
                      (setq input (car values))
                      (when (string-equal (car values) "nil")
                        ;; prompt for this key by read-string if (car vallues) is "nil"
                        ;; read-string will change point
                        (save-excursion
                          (setq input (read-string (format "%s: " key))))))
                  ;;>1. prompt for this key by helm
                  (setq input (helm-other-buffer `((name . ,key) (candidates . ,values)
                                                   (action . (lambda (c) c)))
                                                 "Select"))
                  (setq tmp input))
                (push (cons key tmp) filter-header)
                ;; this is the result
                (push (cons key input) rst))
              )
            ))
        (reverse rst)))

    (defun pns-prompt-for-header-old (header-names)
      "Based on the templates, prompt for each parameters"
      (let ((headers))
        (mapcar (lambda (key)
                  (let ((values (pns-get-header-element-values key headers))
                        tmp)
                    (tracel values)
                    (if (= (length values) 1)
                        (if (and (stringp (car values)) (string-equal (car values) "nil"))
                            (setq tmp (read-string (format "%s: " key)))
                          (setq tmp (car values)))
                      (setq tmp (helm-other-buffer `((name . ,key) (candidates . ,values)
                                                     (action . (lambda (c) c)))
                                                   "Select")))
                    (tracel key tmp)
                    (push (cons key tmp) headers)
                    (cons key tmp)))
                header-names)))

    (defun pns-create-expand-env (header tmpl)
      "Convert header to a expand-env that can be passed to yas-expand-snippet. header is a list, element is (key . value), both key and value are strings. The main job is handle this kind of parameter: (key (k1 v1) (k2 v2)), and changet the key to a symbol from string, change to a list from a cons"
      (let (tmp tmp1)
        ;; elem is a parameter
        (mapcar (lambda (elem)
                  ;; tmp is all possible values for the element key. TODO: where is definiton of tmpl?
                  (setq tmp (cdr (assoc (car elem) (cdr (assoc 'header tmpl)))))
                  ;; tmp1 is the target value
                  (setq tmp1 (cdr elem))
                  (cond ((listp tmp)
                         (mapc (lambda (vv)
                                 (if (consp vv)
                                     (when (string-equal (cdr elem) (car vv))
                                       (setq tmp1 (cdr vv)))))
                               tmp)))

                  (tracel elem tmp tmp1)
                  ;; elem: ("command" . "open"), tmp: "open", tmp1: "open"
                  ;; elem: ("type" . "file"), tmp: "file", tmp1: "file"
                  ;; elem: ("for" . "read"), tmp: (("read" . "<") ("write" . ">") ("append" . ">>") ("readwrite" . "+>")), tmp1: "+>"
                  (list (intern (car elem)) tmp1))
                header)))

    (defun pns-do-expand (&optional filter-header)
      "given header element list, expand a snippet."
      (let* ((header (pns-prompt-for-header filter-header))
             (templates (pns-filter-templates header)))
        (tracel header)
        (mapc (lambda (tmpl)
                (yas-expand-snippet (cdr (assoc 'content tmpl)) (point) (point)
                                    (pns-create-expand-env header tmpl)))
              templates)))

    (defun pns-main ()
      (interactive)
      (pns-do-expand))

    (defun pns-main-shortcut ()
      (interactive)
      (pns-do-expand '(("command" . "create-channel") ("for" . "read") ("file-name" . "\"aaa.b\""))))

    #+end_src
    
    #+RESULTS: methods
    ==============    ==    ==    ===================pns-do-xxx
    =    
    
    #+NAME: test-
    #+begin_src elisp
    (pns-prompt-for-header)
    (pns-get-contents (pns-prompt-for-header))
    (pns-do-expand pns-header-names)
    #+end_src
    
*** ideas
    header的各个元素中，每个元素之间是有关系的。目前采用的方式是随意组合。如第一个元素有2个值，第二元素有3个值，则所有可能取值有2x3=6种。
    但还有种情况，比如第一个元素取第1个值时，第二个元素只能取前2个值；第一个元素取第2个值时， 第二个元素只能取后两个值，则所有取值有2x2处。
    如何表示这种关系呢？使用树完全是可行的，但写起来比较复杂，也不好看。 直接指定一个元素的子节点如何？通过下标。比如(children . (0 1))。 当没有指定children时，则表示children可以取所有值。 这种其实和树的效果是一样的。
*** the nio snippet sample
    Mon Jan  2 09:44:32 2017
    写这个文件花了大约一个多小时，在写的过程中，我观察结构，思考各种可能问题，着重解决分块与组合的问题。 最终想到了一种非常巧妙的方法：使用类似org mode文件的树结构来模板。
    分块有利于模板文件的编写，修改、新增都会比较方便。组合则给进一步的封闭带来便利。这两个方面均可通过org mode文件解决。
    
    一个模板块可以wrap其它模板块。这种主义也要支持。
    
    心得： 必需得通过用例，才能有想法，完全空想，基本上什么也想不出。
    #+BEGIN_SRC text
    ## the four command are independent. To expand all of four, just expand all four step by step


    ##TODO: define a major mode: display the source codes in java format, while all lines begin with a '#' in another look. fold function.


    ##通过第一个参数选择要分别展开哪些宏。第一个参数与后面的参数有什么不同？ 不同点在于在写这个模板时，就是根据第一个参数进行区分的。？这样有没有什么限制？ 应该也可以写sub command，但在不同层级。 比如 #+ 表示第一层， #++表示第二层，#+++表示第三层。 这是文本文件表达树的最佳方式，就像是org mode一样。 通过树的结构，属性继承也会方便很多。同时，感觉没必要保持严格的顺序了，完全可以通过参数指定顺序。 这个想法也是非常牛逼啊！！树的结构，对于修改及新增都有很大的便利性。
    就使用org文件吧， 这样可以继承大量代码。


    ## #++ define global variables
    ,#++ ((buffer-types '(byte int short char long float double)))

    ## nil means the value should be provided by users.
    ,#+ ((command . create-channel) (type . (in out)) (file-name . nil))
    {
        FileOutputStream fout = null;
        try {
            fout = new FileOutputStream(${1:file});
            FileChannel fc = fout.getChannel();

    ,#+ ((command create-buffer) (type . ,buffer-types)(method . (allocate direct-allocate) (size . nil)))
            ByteBuffer buffer = ByteBuffer.allocate(${2:1024});

    ,#+ ((command create-buffer) (type . ,buffer-types)(method . wrap) (array-name . nil)))
            ByteBuffer buffer = ByteBuffer.wrap(${2:1024});

    ,#+ ((command fill-buffer) (buffer-type . ,buffer-types) (content-type . (byte[] String)))
            buffer.clear();
            // fill the buffer with contents to write to a file
            final byte message[] = { 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 };
            for (int i=0; i<message.length; ++i) {
               buffer.put( message[i] );
            }

    ## how to express: this header is dependent on create-channel, type out? I think don't try to do this, this should be ensured by the user
    ,#+ ((comand write-buffer-to-channel))
            buffer.flip();
            fc.write(buffer);
           

    ,#+ ((comand read-buffer-from-channel))
            buffer.clear();
            while (fc.read(buffer) != -1) {

    ,#+ ((command extract-buffer) (buffer-type . ,buffer-types) (content-type . (byte byte[] String)))
                //now file contents saved in buffer, add process codes here
                buffer.flip();
                 int i=0;
                 while (buffer.remaining()>0) {
                     byte b = buffer.get();
                     System.out.print((char)b);
                     i++;
                 }
                
    ,#+ ((comand read-buffer-from-channel))
                buffer.clear();
            }


    ## here type should be the same as the above ones. All vars should be shared, if only they match. A child will inheritates property from its parent. if header 1 contains header 2, then header 1 is the parent, header 2 is the child.
    ## So in below header, it will inheritates 'type' and 'file-name' property from the first one.
    ,#+ ((command . create-channel))
        } catch (FileNotFoundException ex) {
            System.out.println(ex);
        } catch (IOException ex) {
            System.out.println(ex);
        } finally {
            try {
                if (fout != null) {fout.close();}
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }
    #+END_SRC
    
    用org文件重写，效果相当好。
    #+BEGIN_SRC org
    ,* doc
    ## the four command are independent. To expand all of four, just expand all four step by step


    ##TODO: define a major mode: display the source codes in java format, while all lines begin with a '#' in another look. fold function.


    ##通过第一个参数选择要分别展开哪些宏。第一个参数与后面的参数有什么不同？ 不同点在于在写这个模板时，就是根据第一个参数进行区分的。？这样有没有什么限制？ 应该也可以写sub command，但在不同层级。 比如 #+ 表示第一层， #++表示第二层，#+++表示第三层。 这是文本文件表达树的最佳方式，就像是org mode一样。 通过树的结构，属性继承也会方便很多。同时，感觉没必要保持严格的顺序了，完全可以通过参数指定顺序。 这个想法也是非常牛逼啊！！树的结构，对于修改及新增都有很大的便利性。
    就使用org文件吧， 这样可以继承大量代码。

    ,* ((global-variables . (buffer-types '(byte int short char long float double))))
      ## *+ define global variables

    ,* snippet: process files with buffer and channel, nio package
    ,** ((command . create-channel) (type . (in out)) (file-name . nil))
      ## nil means the value should be provided by users.
    ,*** ((command2 . init)
    {
        FileOutputStream fout = null;
        try {
            fout = new FileOutputStream(${1:file});
            FileChannel fc = fout.getChannel();

    ,*** ((command2 . cleanup))
        } catch (FileNotFoundException ex) {
            System.out.println(ex);
        } catch (IOException ex) {
            System.out.println(ex);
        } finally {
            try {
                if (fout != null) {fout.close();}
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }

    ,** ((command create-buffer) (type . ,buffer-types))
    ,*** ((method . (allocate direct-allocate) (size . nil))
            ByteBuffer buffer = ByteBuffer.allocate(${2:1024});

    ,*** ((method . wrap) (array-name . nil))
            ByteBuffer buffer = ByteBuffer.wrap(${2:1024});

    ,** ((command fill-buffer) (buffer-type . ,buffer-types) (content-type . (byte[] String)))
            buffer.clear();
            // fill the buffer with contents to write to a file
            final byte message[] = { 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 };
            for (int i=0; i<message.length; ++i) {
               buffer.put( message[i] );
            }

    ## how to express: this header is dependent on create-channel, type out? I think don't try to do this, this should be ensured by the user
    ,** ((command extract-buffer) (buffer-type . ,buffer-types) (content-type . (byte byte[] String)))
                //now file contents saved in buffer, add process codes here
                buffer.flip();
                 int i=0;
                 while (buffer.remaining()>0) {
                     byte b = buffer.get();
                     System.out.print((char)b);
                     i++;
                 }
                

    ## here type should be the same as the above ones. All vars should be shared, if only they match. A child will inheritates property from its parent. if header 1 contains header 2, then header 1 is the parent, header 2 is the child.
    ## So in below header, it will inheritates 'type' and 'file-name' property from the first one.
    ,** ((command write-to-channel-from-buffer))
            buffer.flip();
            fc.write(buffer);
           
    ,** ((command read-from-channel-to-buffer))
    ,*** ((command2 part1))
            buffer.clear();
            while (fc.read(buffer) != -1) {
            // process buffer content here

    ,*** ((command2 part2))
                buffer.clear();
            }

    #+END_SRC
*** the perl processing file snippet in org mode format
    In this entry, the processing steps are described.
    
    #+BEGIN_SRC org 
    ,* ideas & docs
      - if a parameter has no value, then its value should be prompt for
        such as the '(file)' parameter.
      - maybe add a doc string to a parameter is a good idea. 
        And the doc string is optional. If it not exists, then the parameter key will be used. Angin a good idea.
        A parameter is e.g. '(command open)', 'command' is the parameter's key, 'open' is the parameter's value.
      - ((k1 v1) (k2 (v21 v22))) is the same as the two: ((k1 v1) (k2 v21)) and ((k1 v1) (k2 v22))
        We can always flatten the formmer to the latter to ease our implementation of parse the snippet. and we can make an header has uniform format by always transform it in this format: ((k1 v1 doc1) (k2 v2 doc2) ...), and k1 is always a symbol, v1 is always a cons of (key . value), doc1 is always a string of documentation of this parameter. This idea is great!! It greatly descreases the complexity of codes, for we only have one case to handle. A header is a list of parameters.
        
        When writting snippet, the latter form is better. It helps removing duplicates. But the former form also works. I love this flexibility!
      - put the header in a source block named header, put the expanded codes in a source block named content
        Currently the the header is put in the headline, then it's hard to write long headers.
      - Put the global parameters in the source block name global-definition
        And all the child entry and this entry can refer to that definition
        So just put parameters to the root entry, all the snippet can access to those.
        
        Seems the 'global-definition' and 'header' block have very small differences. The element(which is a parameter) in a 'global-definition' only has one possible value, while a 'header' can has may values. So we can use 'header' as 'global-definition'. 
        
        What we really need is global function definition. Those functions will be created and can be used in the everywhere. 
        Currently we can only support lambda functions to ease the implementation.
      - the processing steps of this file to transform it to a template list
        Note: a template is a list of ((header . H) (content . C))
        1. find the level 1 entry started with 'snippet:'
           Should have only one such entry. root-entry
        2. init current-templates to nil, current-header, current-content to nil,
           
        3. set current-entry to root-entry
           
        4. process the content of current-entry
           Note: content of an entry is the text betwwen the entry's headline and its first child entry's headline, exclusive.
           - for block named 'header', append all parameters of this header to current-header
             Note: I find no need to seperate parameter and functions, because they all server as a environment variable. And our algorithm is that we only prompt for selection or input only when a parameter has mulitple values or has no value. If it has only one value, then nothing will be done, it will server as an environment value only.
           - for block named 'content', append the content to current-content
             without adding any newline characters. So you should add new line in the block if wanted.
           - if this entry is a leaf, 
             then add ((header . current-header) (content . content)) to current-templates.
             then restore current-header and current-content to the original value.
             
           - else for all direct child entrys:
             loop with current-entry in all direct child entrys:
             repeat step 4.
             
        5. now current-templates contains all template of this snippet tree.
           
      - helm source candidate
        the level one snippet entry's headline and
        the direct child's headlines of level one shortcut entry
        will be added as helm source candidate
        
        For both candidates, the level one snippet entry will first be processed to a templates list.
        Note: maybe this can be processed at init stage and saved for latter use, and update when needed(such as the file has a newer version).
        Then for the first type of candidate, the filter will be set to '()
        for the second type of candidate, the filter will be set to source block 'filter' of that entry.
        Note: a filter is a list of parameters, and is used to give initial value to a parameter. Then that parameter will not be prompt for selction or value.
        
        
    ,* snippet: processing files, open, read, write, close
      ,#+name: header
      ,#+begin_src elisp
      ((snippet-name xxxxx))
      ,#+end_src
      
    ,** ((command open) (target file) (for ((read '<') (write '>') (append '>>') (readwrite '+>'))) (file))
       ,#+name: header
       ,#+begin_src elisp
       ((command open) (target file)
        (for (read <) (write >) (append >>) (readwrite +>))
        (file))
       ,#+end_src
       
       ,#+name: content
       ,#+begin_src perl :results output
       open my $fh, '`for`', `file` or die "Open file failed";
       ,#+end_src
       
       Notes on variable binding:
       For element type string, name, name-value, name-key all bind to the same string;
       For element type cons, name is binded to the cons, name-key will be binded to (car name), name-value will be binded to (cdr name).
       e.g.:
       if `for` is '(read '<')', `for-value` will be 'read', `for-key` will be '<'.
       if `target` is 'file', then `target-key`, `target-value` are all 'file'.
       
    ,** ((command open) (target pipe) (for ((read '|-') (write '-|'))) (command))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command open) (target pipe) (for (read |-) (write -|)) (shell-command))
       ,#+end_src
       
       ,#+name: content
       ,#+begin_src perl :results output
       open my $fh, '`for`', `shell-command` or die "Open command failed";
       ,#+end_src
       
    ,** ((command close))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command close))
       ,#+end_src
       
       
       ,#+name: content
       ,#+begin_src perl :results output
       close $fh;
       ,#+end_src
       
    ,** ((command read)  (file-handler) (to))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command read)  (file-handler) (to))
       ,#+end_src
       
    ,*** ((type line))
        ,#+name: header
        ,#+begin_src perl :results output
       ((type line))
        ,#+end_src
        
        
        read a line from a file handler
        ,#+name: content
        ,#+begin_src perl :results output
       `to` = <`file-handler`>;
        ,#+end_src
    ,*** ((type whole-content-as-string))
        ,#+name: header
        ,#+begin_src perl :results output
       ((type whole-content-as-string))
        ,#+end_src
        
        
        read the file's whole content as a string
        ,#+name: content
        ,#+begin_src perl :results output
        local $/;
        `to` = <`file-handler`>;
        ,#+end_src
        
        
    ,* shortcut
      shortcut is a way to predefine some parameters so that these parameters will not be prompted to user for value.
      
    ,** open a file for read, and then close
       This shortcut contains two header, the first one will define three element. The whole:
       ,#+NAME: filter
       ,#+begin_src elisp
       (((command open) (target file) (for read))
        ((command close)))
       ,#+end_src
       Element is a header, each element will be processed in turn.
    #+end_src
       
       
    #+END_SRC
*** hatch codes: parse org mode file to templates list
    INFO. All org mode related codes
    #+NAME: no-name
    #+begin_src elisp

(org-entry-delete)
(org-entry-beginning-position)
(org-entry-end-position)
(org-entry-get)
(org-entry-get-with-inheritance)

(org-entry-properties)
(org-entry-is-todo-p)

(defun org-in-src-block-p (&optional inside)

(org-babel-src-block-names pns-snippet-file)

(defun org-goto-first-child ()
  "Goto the first child, even if it is invisible.
Return t when a child was found.  Otherwise don't move point and
return nil."

(defun org-back-to-heading (&optional invisible-ok)
  "Call `outline-back-to-heading', but provide a better error message."

(defun org-get-next-sibling ()
  "Move to next heading of the same level, and return point.
If there is no such heading, return nil.
This is like outline-next-sibling, but invisible headings are ok."


(defun outline-next-visible-heading (arg)

(defun outline-next-heading ()
(outline-level)
(org-entry-put)
(org-find-entry-with-id)

;; get the entry text, after heading, entire subtree
(org-get-entry)

(defun org-babel-next-src-block (&optional arg)
  "Jump to the next source block.
With optional prefix argument ARG, jump forward ARG many source blocks."
  (interactive "p")
  (org-next-block arg nil org-babel-src-block-regexp))


    #+end_src
    
    #+NAME: init
    #+begin_src elisp
(require 'aspk-debug)
    #+end_src
    
    #+NAME: vars
    #+begin_src elisp
    (defvar pns-snippet-file nil "snippet file name")
    (setq pns-snippet-entry-regexp  "^\*+\s+snippet.*")
    ;; (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp)
    #+end_src
    
    #+NAME: init
    #+begin_src elisp
    ;; (setq pns-snippet-file "perl-file-processing.org")
    (setq pns-snippet-file (expand-file-name "snippets/file-processing.org"))
    #+end_src
    
    
    DONE. a function get all src block, (name, content, belonging-heading-level), in the same order they are defined.
    #+NAME: vars
    #+begin_src elisp
    (setq pns-src-block-name-regexp "\\(header\\|content\\)")
    #+end_src
    
    #+NAME: methods
    #+begin_src elisp
    (defun pns-get-all-src-blocks (snippet &optional entry name)
      "Get all src blocks of the given snippet file name, return as a list. All src blocks should be in a entry, or there will be error. If the entry is provided, then only get that entry's src blocks. entry is regexp to match a headline. If name is given, only get blocks with NAME."
      (let (tmp rst)
        ;; create temp buffer without undo record or font lock. (more efficient)
        ;; first space in temp buff name is necessary
        (and (get-buffer " myTemp") (kill-buffer " myTemp"))
        (set-buffer (get-buffer-create " myTemp"))
        (insert-file-contents snippet nil nil nil t)

        ;; get only the entry's content
        (when entry
          (goto-char 1)
          (if (re-search-forward entry nil t)
              (let ((heading (match-string 0))
                    (entry (org-get-entry)))
                (erase-buffer)
                (insert heading)
                (insert "\n")
                (insert entry))
            (error "Entry %S not found, file: %s, src block name: %s." entry snippet name)))

        ;; (write-file "aaa")
        (goto-char 1)
        (while (setq tmp (pns-get-src-block-info name))
          (push tmp rst))
        (prog1 (reverse rst)
          (kill-buffer " myTemp"))))

    (defun pns-get-src-block-info (name)
      "Return a accoc list of block info, searching form current position, current buffer. If no src blocks, return nil, and position will not be moved.
    The codes are copied form org-babel-find-named-block "
      (interactive)
      (or name (setq name "\\(.*\\)"))
      (let* ((case-fold-search t)
             (regexp (concat org-babel-src-name-regexp name "[ \t(]*[\r\n]\\(?:^#.*[\r\n]\\)*"
                             (substring org-babel-src-block-regexp 1))))

        (when (re-search-forward regexp nil t)
          (append
           ;; position: beginning and end
           (list (cons 'beginning (match-beginning 0))
                 (cons 'end (match-end 0)))
           ;; src block name, lang, content
           (let ((property-name '(nil name nil lang nil nil content)))
             (mapcar (lambda (idx)
                       (cons (nth idx property-name)
                             (if (equal (nth idx property-name) 'content)
                                 (pns-unquote-src-block-content
                                  (substring-no-properties (or (match-string idx) "")))
                               (substring-no-properties (or (match-string idx) "")))))
                     '(1 3 6)))
           ;; belonging heading and level
           (save-excursion
             (let ((p (point)))
               (org-back-to-heading)
               (move-beginning-of-line 1)
               (if (re-search-forward "^\\(\\*+\\)\s+\\(.*\\)" p t)
                   (list (cons 'level (length (match-string 1)))
                         (cons 'heading (substring-no-properties (match-string 2)))))))))))

    ;; there is a bug in regexp-quote: '\\|' will be quoted to '\\\\|'

    (defun pns-unquote-src-block-content (content)
      "Remove all leading ',' in each line of content"
      (replace-regexp-in-string "^\\(\s*\\)," "" content)) ;;remove all leading line helps indent.

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    (defun pns-tmp ()
      (interactive)
      (message "%s" (pns-get-src-block-info pns-src-block-name-regexp)))
    #+end_src
    
    
    convert the source blocks to templates list:
    Given src blocks, get the templates.
    #+NAME: methods
    #+begin_src elisp
    ;; add a filed: leafp
    (defun pns-assoc (key list)
      (cdr (assoc key list)))

    (defun pns-add-leafp-to-src-blocks (blocks)
      (let (elem rst)
        (while blocks
          (setq elem (car blocks))
          (setq blocks (cdr blocks))
          (if blocks
              (if (>= (pns-assoc 'level elem) (pns-assoc 'level (car blocks)))
                  (push (append (list (cons 'leafp t)) elem) rst)
                (push (append (list (cons 'leafp nil)) elem) rst))
            (push (append (list (cons 'leafp t)) elem) rst)))
        (reverse rst)))

    (defun pns-convert-block-list-to-tree (blocks)
      "Covert a block list to a tree based on level. use the children and parent property"
      (let* ((elem nil)
             (idx 0)
             ;; below line will not work, the rst will change every time. Acturally, it will be the same value the last time run
             ;; (rst '((children . (a)) (parent . nil)))
             ;; this works though
             (rst (list (list 'children idx) (list 'parent)))

             ;; parents save the current level parent block
             (parents (list rst rst rst rst rst rst rst rst rst))
             (level nil)
             (parent nil) (children nil)
             )

        (tracel elem rst parents level parent children idx)

        (while blocks
          (setq elem (car blocks))
          (setq level (pns-assoc 'level elem))
          (setq parent (nth (- level 1) parents))
          (unless parent (error "parent for level %s nil" (- level 1)))

          ;; (message "level: %s, parent: %s" level parent)
          ;; add 'parent' and 'children' property to this elem, add saved it to (parents level)
          ;; (message "before elem: %s" elem)
          ;; (setq elem (append elem `((children . (a)) ,(cons 'parent (list parent)))))
          (setq elem (append elem (list (list 'children (format "%s-%s" (incf idx) level))
                                        (list 'parent parent)
                                        )))
          ;; (message "after  elem: %s" elem)
          (setf (nth level parents) elem)

          ;; add this elem to parent as a child
          ;; both the above operations should be destructive.
          (setq children (pns-assoc 'children parent))
          ;; (message "before children: %S" children)
          (unless children (error "children nil. Parent: %S" parent))

          (setcdr children (append  (cdr children) (list elem)))
          ;; (message "after  children: %S" children)
          ;; (message "rst: %S" rst)
          ;; (cdr nil)

          (setq blocks (cdr blocks)))
        rst))



    ;; a bug in emacs lisp: seems a list with the same symbol elemnt will has the same address.
    ;; (eq (list 'a 'b) (list 'a 'b))
    ;; After I change this line :
    ;; (setq elem (append elem `((children . (a)) ,(cons 'parent (list parent)))))
    ;; TO:
    ;; (setq elem (append elem (list (list 'children (format "%s-%s" (incf idx) level))
    ;; (list 'parent parent))))
    ;; Then the program works.

    ;; This is just waist of time!! emacs lisp's desctructive operateions are full of bug!!!! I have waste about 3 hours on this!! Fuck!!!!

    ;; Found another bug:
    ;; first time run pns-convert-block-list-to-tree, it gives good answer
    ;; then it gives double the good anwser, then triple, ...
    ;; DOn't know why
    ;; FOund the root cause:
    ;; the rst value will be not the same each time the program enter. Fuck!!
    ;; (let ((elem nil)
    ;; (rst '((children . (a)) (parent . nil)))


    (defun pns-print-tree (tree)
      ;; (message "Tree: %s" tree)
      (message "level: %s, name: %s"
               (pns-assoc 'level tree)
               (pns-assoc 'name tree))
      (mapc (lambda (tt)
              (if (listp tt)
                  (pns-print-tree tt))
              )
            (pns-assoc 'children tree)))


    ;; Now the function works!!!
    (defun pns-create-templates (block-tree c-header c-content)
      "Assue content block is behind of header block or it will be error."
      (tracel c-header)
      (let ((name (pns-assoc 'name block-tree))
            (children (pns-assoc 'children block-tree)))
        ;; (message "lenth children=%s" (length children))
        (if (= (length children) 1)
            ;;this is a leaf
            (cond ((string-equal name "header")
                   (setq pns-tmp-header c-header))
                  ((string-equal name "content")
                   (add-to-list 'pns-tmp-templates
                                (list (cons 'header pns-tmp-header) (cons 'content c-content))
                                t)))
          ;; this is a parent
          (mapc (lambda (tt)
                  (when (listp tt)
                    (let ((name (pns-assoc 'name tt))
                          (content (pns-assoc 'content tt)))
                      (cond ((string-equal name "header")
                             (pns-create-templates tt
                                                   (append c-header (read content))
                                                   c-content))
                            ((string-equal name "content")
                             (pns-create-templates tt
                                                   c-header
                                                   (concat c-content content)))))))
                children))))

    (defun pns-convert-to-string-filed (lst)
      (tracel lst)
      (mapcar (lambda (parameter)
                (if (listp parameter)
                    (cons (format "%s" (car parameter))
                          (if (> (length (cdr parameter)) 1)
                              (pns-convert-to-string-filed (cdr parameter))
                            (format "%s" (car (cdr parameter)))))
                  ;; for (name v1 v2 v3) cases. lst now is (v1 v2 v3)
                  (format "%s" parameter)))
              lst))

    ;; This works as main function

    (defun pns-create-templates-1 (snippet-file)
      "Given snippet org file, return the templates list"
      (setq pns-tmp-header nil)
      (setq pns-tmp-templates nil)
      (pns-create-templates
       (pns-convert-block-list-to-tree (pns-get-all-src-blocks snippet-file pns-snippet-entry-regexp  pns-src-block-name-regexp))
       nil nil)

      (mapcar (lambda (tmpl)
                (let ((header (pns-assoc 'header tmpl))
                      (content (pns-assoc 'content tmpl)))
                  (list (cons 'header (pns-convert-to-string-filed header))
                        (cons 'content content))))
              pns-tmp-templates)
      )

    (defun pns-main-update-templates ()
      (interactive)
      ;; for open command:
      (setq pns-header-names '("command" "target" "for" "file"))
      
      ;; for close command:
      (setq pns-header-names '("command"))
      
      ;; for read command:
      (setq pns-header-names '("command" "file-handler" "to" "type"))
      
      (setq pns-templates (pns-create-templates-1 pns-snippet-file))
      (message "pns-templates updated.")
      )

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    ;; (message "Rst: %S"
    (pns-convert-block-list-to-tree (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp  pns-src-block-name-regexp))
    ;; )


    ;; (message "Rst: %S"
    (pns-print-tree
     (pns-convert-block-list-to-tree '(
                                       ((level . 1) (name . "A"))
                                       ((level . 2) (name . "B1"))
                                       ((level . 2) (name . "B2"))
                                       ((level . 3) (name . "C1"))
                                       ))
     )
    (defun my-append-1 (a b)
      (concat a b))

    ;; (append nil (read "'((a b) (c d))"))

    (defun my-append (a b)
      (tracel a b)
      (append (and a (read (concat "" a))) (and b (read (concat "" b)))))

    (setq a (append nil (read "((command open) (target file)
        (for ((read <) (write >) (append >>) (readwrite +>)))
        (file))
    ")))


    (mapcar (lambda (block)
              (message "level: %s, name: %s, leafp: %s."
                       (pns-assoc 'level block)
                       (pns-assoc 'name  block)
                       (pns-assoc 'leafp  block))
              (cond ((string-equal (pns-assoc 'name block) "header")
                     (if (pns-assoc 'level block)
                         (push (append current-header (pns-assoc 'header block)) ))
                     ))
              )
            (pns-add-leafp-to-src-blocks (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp  pns-src-block-name-regexp)))


    #+end_src
    
*** how to run
    1. run pns-create-templates and assign the result to pns-templates
       before asssing, should convert filed to string
       The input file is "perl-file-processing.org", saved in variable pns-snippet-file.
       
    3. manualll set pns-header-names
       Latter we should calculate the header dynamiccly.
       
       for open command:
       (setq pns-header-names '("command" "target" "for" "file"))
       
       for close command:
       (setq pns-header-names '("command"))
       
       for read command:
       (setq pns-header-names '("command" "file-handler" "to" "type"))
       
    4. run pns-main
       but first bind below variables, because we don't bind it in the env now.
       
       For open command, also bind the two variables.
       (setq for-value ">")
       (setq for-key "read")
*** hatch codes:  support shortcut
    #+NAME: vars
    #+begin_src elisp
(defvar pns-shortcuts nil "this is a temp variable to save current list of shortcut")
(setq pns-shortcut-entry-regexp  "^\*+\s+shortcut.*")
    #+end_src
    
    #+RESULTS: vars
    =@
    ==@
    ==@
    =    
**** read all shortcuts from a snippet file
     Input: pns-snippet-file, output: pns-shortcuts
     #+NAME: methods
     #+begin_src elisp
     (defun pns-create-shortcuts (file)
       "create a list of shortcut from org mode snippet `file'"
       (mapcar (lambda (src-block)
                 (list (cons 'header (mapcar (lambda (header)
                                               (pns-convert-to-string-filed header))
                                             (read (pns-assoc 'content src-block))))
                       (cons 'name (pns-assoc 'heading src-block))))
               (pns-get-all-src-blocks file pns-shortcut-entry-regexp  pns-src-block-name-regexp)))

     (defun pns-update-shortcuts ()
       (interactive)
       (setq pns-shortcuts  (pns-create-shortcuts pns-snippet-file)))


     ;; (setq aa (pns-create-shortcuts pns-snippet-file))
     (defun pns-main-shortcut ()
       (interactive)
       (let ((cand (mapcar (lambda (shortcut)
                             (cons (pns-assoc 'name shortcut)
                                   (pns-assoc 'header shortcut)))
                           pns-shortcuts)))
         (helm-other-buffer `((name . "shortcut")
                              (candidates . ,cand)
                              (action . (lambda (shortcut)
                                          (mapc (lambda (header)
                                                  (pns-do-expand header))
                                                shortcut))))
                            "Shortcut")))

     ;; (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp)

     #+end_src
     
     pns-main-shortcut do the job. but a strange thing: the snippet will be inserted to another most recent buffer!!! not current.
     
** implementation
*** tangle
    #+name: sources
    #+begin_src elisp :noweb yes :tangle pns.el
    <<vars>>
    <<methods>>
    <<misc>>
    <<init>>
    #+end_src
** issues
*** DONE " myTemp" not killed may cause snippet file not found
    CLOSED: [2017-01-03 Tue 11:45]
    - State "DONE"       from ""           [2017-01-03 Tue 11:45]
    If snippet is relative path, then if this function exit without kill the buffer, then the buffer will keep exists.
    Fix by first kill the buffer.
*** DONE let the user input value if a parameter's value is "nil"
    CLOSED: [2017-01-03 Tue 15:43]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 15:43] \\
      Create a special case for this situation.
      (if (and (stringp (car values)) (string-equal (car values) "nil"))
      
      At create expand-env,  contains function, and prompt for input.
    - State "STARTED"    from ""           [2017-01-03 Tue 14:45]
    Now the parameter is just selected.
*** DONE create a function to create expand-env for yas-expand-snippet
    CLOSED: [2017-01-03 Tue 16:00]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 16:00]
    - State "STARTED"    from ""           [2017-01-03 Tue 15:54]
    Currently the codes are in another function.
    
*** DONE build pns-header-names dynamically based on pns-templates
    CLOSED: [2017-01-03 Tue 17:26]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 17:26]
      Rewrite pns-prompt-for-header. the codes not good.
      The codes 
    - Note taken on [2017-01-03 Tue 17:20] \\
      Arealdy fixed the bug. And find a new bug in create templates from snippet file: if a parameter has multiple values, it will have only one value, which is the string of that list.
    - State "STARTED"    from ""           [2017-01-03 Tue 16:07] \\
      This function should be modified.
      (defun pns-prompt-for-header (header-names)
    Now it is specified in pns-main-1
    
*** DONE create templates bug: multiple parameter values will be one
    CLOSED: [2017-01-03 Tue 17:43]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 17:43] \\
      Codes is correct. It is the snippet error. So modify snippet to fix it.
      
      This function do the conversion. recursively.
      (defun pns-convert-to-string-filed (lst)
    - State "STARTED"    from ""           [2017-01-03 Tue 17:33]
    find a new bug in create templates from snippet file: if a parameter has multiple values, it will have only one value, which is the string of that list.
    
*** CANCELLED Symbol’s value as variable is void: for-value
    CLOSED: [2017-01-03 Tue 18:07]
    - State "CANCELLED"  from "STARTED"    [2017-01-03 Tue 18:07] \\
      the name represent the value, no need to write name-value. So I feel this function isn't that so useful.
    - Note taken on [2017-01-03 Tue 17:51] \\
      expand-env works like let*. so we can just add a function to create the variables.
      Below codes works
      
      #+NAME: no-name
      #+begin_src elisp
          (yas-expand-snippet "open my $fh, \"`for-value`\", ${1:file};" (point) (point) '((for (read "<++")) (for-value (if (consp for) (cdr for) for))))
      #+end_src
    - Note taken on [2017-01-03 Tue 17:46] \\
      for-key   should be (if (consp for) (car for) for)
      for-value should be (if (consp for) (cdr for) for)
      
      This works for all expand-evn variable.
    - State "STARTED"    from ""           [2017-01-03 Tue 17:45]
    Symbol’s value as variable is void: for-value', open or die "Open command for [yas] elisp error: Symbol’s value as variable is void: for-key failed";
    
*** DONE write a snippet file for java file processsing,  by nio
    CLOSED: [2017-01-03 Tue 23:28]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 23:28]
      file saved in ./snippets/file-processing.org
    - State "STARTED"    from "TODO"       [2017-01-03 Tue 20:10]
    - State "TODO"       from ""           [2017-01-03 Tue 18:17]
    create a new snippet file under ./snippets/.
    
    The perl file processing snippet now works quite good. Maybe we can share headers between different language, then converting to indepenndent templates. This the key to uniform all language with same promption. But the drawbacks is maybe we need prompt for more data to make it uniform.
    Add many lanuage's file processing apis in to one snippet file, and see how it works, do there will be some problem.
    
    #+NAME: no-name
    #+begin_src elisp
(setq pns-snippet-file (expand-file-name "snippets/file-processing.org"))
(pns-main-1)
    #+end_src
    
*** write a snippet file for java file processsing,  by io
    
*** DONE multiple snippet files supports, integrated to helm-c-yasnippet
    CLOSED: [2017-01-05 Thu 11:48]
    - State "DONE"       from "STARTED"    [2017-01-05 Thu 11:48] \\
      tested. With little bug for org.org snippet.
    - Note taken on [2017-01-05 Thu 11:44] \\
      codes write done. Based on the underlining functions, the function can be created quite easy.
    - Note taken on [2017-01-05 Thu 10:56] \\
      one snippet file is a module. all files is a list of module, pns-modules.
    - State "STARTED"    from ""           [2017-01-05 Thu 10:08]
      What finished now is processing a single snippet file, which has two parts: a snippet entry and a shortcut entry.
    Each file contains a list of templates. different file's templates are independent.
    
    #+NAME: vars
    #+begin_src elisp
(defvar pns-modules nil "List of modules. a module corespongidng to a snippet file")
(defvar pns-module-name nil "this var is used to save current module name when processing")
(defvar pns-snippet-dir (expand-file-name "./snippets") "The directory for all snipppet files")
    #+end_src
    
    create pns-modules
    #+NAME: methods
    #+begin_src elisp
    (defun pns-create-module-1 (file)
      (let (pns-templates pns-shortcuts (pns-snippet-file file))
        (pns-main-update-templates)
        (pns-update-shortcuts)
        (list (cons 'name (file-name-nondirectory file))
              (cons 'templates pns-templates)
              (cons 'shortcuts pns-shortcuts))))

    (defun pns-create-modules (dir)
      ;; iterate all file names under directory dir with an optional filter function, recursively
      (require 'f)
      (mapcar (lambda (file)
                ;; (message "File: %s" file)
                ;; Here file is file name, add processing codes here
                (pns-create-module-1 file))
              ;; the second parameter can be a function filtering the file names.
              (f-files dir nil t)))

    (defun pns-create-modules-run ()
      "A run funcion alwasy has no parameter and no return value"
      (interactive)
      (setq pns-modules (pns-create-modules pns-snippet-dir)))
    #+end_src
    
    select module with helm
    #+NAME: methods
    #+begin_src elisp
    (defun pns-main-module ()
      "using helm to select a module and run. Input is pns-modules"
      (interactive)
      (let ((cand (mapcar (lambda (module)
                            (cons (pns-assoc 'name module) module))
                          pns-modules)))
        (helm-other-buffer `((name . "module")
                             (candidates . ,cand)
                             (action . (lambda (module)
                                         (let ((pns-templates (pns-assoc 'templates module))
                                               (pns-shortcuts (pns-assoc 'shortcuts module)))
                                           (pns-main-shortcut)))))
                           "Module")))
    #+end_src
    
    
*** throw error when current idx has more than one parameter keys
    Or the user will no know what going wrong.
    
    THis function:
    (defun  pns-prompt-for-header () 
    "Prompt for each parameter. Assumption: in the filtered templates, only one parameter key exists at pos idx. Not checked if there are two, but will use the first one silently. Snippet file should ensule this."
    
*** DONE if root entry don't have a header src block, then children will be nil
    CLOSED: [2017-01-03 Tue 22:35]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 22:35]
    - State "STARTED"    from ""           [2017-01-03 Tue 22:26]
    Root cause is parents's second element is nil, so the children will be nil.
    Should fix by setting all element of parents to rst.
    And also throw an error when children is nil, or idx exceed the max element in parents.
    
    (defun pns-convert-block-list-to-tree (blocks)
    "Covert a block list to a tree based on level. use the children and parent property"
    (let* ((elem nil)
    (idx 0)
    ;; below line will not work, the rst will change every time. Acturally, it will be the same value the last time run
    ;; (rst '((children . (a)) (parent . nil)))
    ;; this works though
    (rst (list (list 'children idx) (list 'parent)))
    
    ;; parents save the current level parent block
    # (parents (list rst rst rst nil nil nil nil)) ;; this will work
    (parents (list rst nil nil nil nil nil nil))
    
*** DONE a bug: header ((buffer-types Byte Char Int)), pns-convert-to-string-filed  not works
    CLOSED: [2017-01-03 Tue 22:25]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 22:25]
    - State "STARTED"    from ""           [2017-01-03 Tue 22:23]
      
    Below is modified vesion. seems it works
    (defun pns-convert-to-string-filed (lst)
    (tracel lst)
    (mapcar (lambda (parameter)
    (if (listp parameter)
    (cons (format "%s" (car parameter))
    (if (> (length (cdr parameter)) 1)
    (pns-convert-to-string-filed (cdr parameter))
    (format "%s" (car (cdr parameter)))))
    (format "%s" parameter)))
    lst))
    
*** DONE seems if parameter is (name value1 value2), the helm selection will hang
    CLOSED: [2017-01-03 Tue 21:49]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 21:49] \\
      pns-contains don't consider this situation.
    - State "STARTED"    from ""           [2017-01-03 Tue 21:34]
    (name (key1 value1) (key1 value2)) works.
    
*** SOMEDAY can't reference another variables in header
    - State "SOMEDAY"    from "STARTED"    [2017-01-03 Tue 22:36]
    - Note taken on [2017-01-03 Tue 22:14] \\
      this variable should be expanded before pass to yas-expand-snippet.
      May be I should give up this now.
    - State "STARTED"    from ""           [2017-01-03 Tue 21:58]
    e.g.
    ((buffer-types Byte Int ...))
    ((command create-buffer) (type buffer-types))
    type refer to buffer-types
    
    But in pns-templates, type's reference value 'buffer-types' will be convert to string directly.
    ("type" . "buffer-types")
    
    Solution: should define a method to show how to do variable reference, now they will all be converted to string.
    I will use the commer syntax. if a name is preceeded by a commer, then we will not convert it to a string. So the definition will be changed to:
    ((buffer-types Byte Int ...))
    ((command create-buffer) (type ,buffer-types))
    
*** DONE select type to Int, but in expanded codes it will always be Double
    CLOSED: [2017-01-03 Tue 23:00]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 23:00] \\
      a bug in pns-create-expand-env
    - State "STARTED"    from ""           [2017-01-03 Tue 22:37]
    DoubleBuffer buffer = DoubleBuffer.directAllocate(111);
    
    pns.el:pns-create-expand-env:148:	elem=(command . create-buffer), tmp=create-buffer, tmp1=create-buffer
    pns.el:pns-create-expand-env:148:	elem=(type . Short), tmp=(Byte Char Int Short Char Long Float Double), tmp1=Double
    pns.el:pns-create-expand-env:148:	elem=(method . allocate), tmp=(allocate directAllocate), tmp1=directAllocate
    pns.el:pns-create-expand-env:148:	elem=(size . 111), tmp=nil, tmp1=111
    Mark set
    
    
*** DONE add shortcut to nio snippet org file
    CLOSED: [2017-01-04 Wed 17:40]
    - State "DONE"       from "STARTED"    [2017-01-04 Wed 17:40] \\
      use pns-update-shortcuts to read shortcuts from snippet file and saved to pns-shortcuts
      use pns-main-shortcut to trigger every shortcut.
      Works very good!
    - Note taken on [2017-01-04 Wed 17:09] \\
      By make use of the former functions, the job is easy.
      So it is good to write general functions. not use global variables.
    - Note taken on [2017-01-04 Wed 17:06] \\
      Done the basic codes. Works with little bug.
    - Note taken on [2017-01-04 Wed 13:58] \\
      Code modification done. Possiable to support shortcut. run pns-main-shortcut to see the effect.
    - Note taken on [2017-01-04 Wed 11:42] \\
      try to impelemnt. just add a parameter filter-header will works.
      But below will cause template nill.
      
      (pns-do-expand '(("command" . "create-channel") ("for" ("read" "Input")))))
      
      below one works, but "for" still be promted:
      (pns-do-expand '(("command" . "create-channel") ("for" . "read"))))
      This wroks as expected.
      Fix this by adding a judge: if the element exists in filter-header, then don't select it, just use its value.
      
    - State "STARTED"    from ""           [2017-01-03 Tue 23:35]
    one to read file, including create channel, create buffer, read from channel to buffer, .., close file.
    one to write file.
    
    a shortcut is just a list of expanded headers. it locates under '^* shortcut.*' entry.
    TO the user, it works exactly the same as a snippet entry.
    
    Solution: just pass a filter-header(current the initial value is nil, so select every template in pns-templates). Then only the needed parameters needs to be selected.
    
*** parameter format related
**** default value for parameter
     XXX But seems now it's hard to add addtional data to a parameter without modifing its type.
     
     It can be easily added.
     Current structure of a parameter:
     (key (select-value real-value))
     
     Then just add default value to the third place, 
     (key (select-value real-value default-value)). If select-value is the same as real-value, just set they same.
     
     The format is compatible to the old one.
     
     Default value is displayed when selecting, if press enter, then key value will be nil.
     
**** parse value as symbol: a reference to another key
     why this is useful?
     Then I can define a 'global variable'(may be in another src block instead of header), and refer to that variable in another 'header' src block.
     This is quite useful in this situation:
     In a shortcut, two header refers to the same variable(such as filehandle, filename), by get that info and saved to a 'global variable', we avoid prompt for that info twice.
     
     The 'global variable' is used to collect all parameters needed by the whole shortcut headers, and in the header definition, we just pass all values.
     
     Maybe we can use this syntax to express a variable reference:
     (key value)      : value is treated as string
     (key $reference) : reference is treated as a symbol. prefixed by a '$'
     (key @doc) : doc is the document for this parameter. prefixed by a '@'. Or (key "@this is a doc contais blanks"). and (key (select-value real-value @doc-for-selected-value)) also works, it add a doc to this value.
     It will be displayed as name for helm.
     (key =default-value): default-value is the default value of this parameter. prefixed by a "=".
     
     All those parameters are regular chars in lisp.
     '#', '?' is not valid
     
     test:
     #+NAME: no-name
     #+begin_src elisp
(setq a (read "(key *reference))"))

(format "%S" (nth 1 a))

(format "%S" (nth 0 a))




     #+end_src
     
**** should provide a way to define non selectable parameters.
     e.g. buffer-types parameter just servered as an global variable, not the headers.
     
     To fix, there are two ways: define other src names, such as 'global-definition' instead of 'header', the latter is used for prompt for input.
     two: still use header name, but...
     I prefer the first one.
     
*** CANCELLED refactory: pns-prompt-for-header
    CLOSED: [2017-01-04 Wed 21:37]
    - State "CANCELLED"  from ""           [2017-01-04 Wed 21:37]
    - Note taken on [2017-01-04 Wed 21:33] \\
      seems no need to do so. Because in shortcut we will use this feature.
    TODO: seems we can return the real-value directly by helm. Now returned the select-value.
    
    this function: values is a list of string. better to use a list of cons if the parameter value is cons. Then no need to convert latter.
    
    (defun  pns-prompt-for-header (&optional filter-header) 
    
    
    (setq values (pns-get-header-element-values key filter-header))
    
    (setq input (helm-other-buffer `((name . ,key) (candidates . ,values)
    (action . (lambda (c) c)))
    "Select"))
    
    pns.el:nil:113:	values=(create-channel create-buffer fill-buffer extract-buffer write-to-channel-from-buffer read-from-channel-to-buffer import-needed-package)
    pns.el:nil:113:	values=(read write)
    pns.el:nil:113:	values=(part1 part2)
    pns.el:nil:113:	values=(nil)
    i
*** shortcut: string value, the '"' will missing in the generated codes.
    e.g. after expanded, file name  is `aa.bb' instead of `"aa.bb"'
    (file-name "aa.bb")
    
*** DONE shortcut: import part will be inserted after the fowwling parts
    CLOSED: [2017-01-04 Wed 21:15]
    - State "DONE"       from "STARTED"    [2017-01-04 Wed 21:15]
    - State "STARTED"    from ""           [2017-01-04 Wed 20:01]
    caused by prompt for file name. if i set value for file-name, then it is ok.
    (file-name "aa.bb")
    
    This issue should be caused by helm, not yasnippet. Because helm will save current position.
    And two helm session is nested.
    
    After tested, it is 'read-string' that make point with wrong value.
    in shortcut,pooint: 19803
    point: 19803
    after point: 19872
    in shortcut,pooint: 19872
    before read-string. ponint:19872
    is-buffer-file-temp called
    afeter read-string. ponint:19803
    point: 19803
    after point: 19906
    in shortcut,pooint: 19906
    point: 19906
    after point: 19961
    in shortcut,pooint: 19961
    p
    
*** write function test codes
    Target: a test is in the "test-method" src block. The result is in the "test-result" src block.
    Provide a function to run all the test, and print not passed cases.
    
*** DONE src block: if lang is org, then some special chars will be quoted
    CLOSED: [2017-01-05 Thu 12:22]
    - State "DONE"       from "STARTED"    [2017-01-05 Thu 12:22]
    - Note taken on [2017-01-05 Thu 11:54] \\
      maybe we can just remove the leading ','.
    - State "STARTED"    from ""           [2017-01-05 Thu 11:51]
    So the expanded content will contains a ',' before.
    ,#+name: content
    ,#+begin_src csharp
    
    ,#+end_src
    
*** use headings to select detailed snippets instead of the fisrt parameter
    
*** add mode support
    Only that mode's snippet can be selected.
    With a prefix, select form all modes.
    
    Then I should add another field to module: mode
    
    create all mode dir
    #+NAME: no-name
    #+begin_src elisp

    (mapcar (lambda (mode)
              (setq dir (format "%s/%s-mode" pns-snippet-dir mode))
              (unless (file-exists-p dir) (message "Creating dir: %s" dir) (mkdir dir t))
              )
            '("c++" "c" "cc" "cmake" "csharp" "css" "emacs-lisp" "erlang" "html" "inf-ruby" "java" "javascript" "js" "js2" "js3" "jsp" "less-css" "lua" "nxml" "objc" "org" "perl" "python" "rhtml" "rspec" "ruby" "scala" "scss" "sh" "snippet" "web"))

    #+end_src
    
    shortcut may be a general idea. It can combine any snippet sources. The aspk-code-snippet works good seems. we should only use key words to search for a snippet, wether if it is a snippet or a shortcut.
    
*** pns should also support the yas snippet function.
    for simple snippet, aspk-code-snippet works better. simple snippet can be created quickly.
    
    But for complex snippet, aspk-new-snippet is better. The writting is quite complex.
    
*** DONE new idea: delete shortcut, create expand env dynamically and look backward, every headlines are selectable
    CLOSED: [2017-01-07 Sat 20:06]
    - State "DONE"       from "STARTED"    [2017-01-07 Sat 20:06] \\
      Code finished. Call pns-expand-template-by-name to expand a template by selecting its name.
      The snippets/java-mode/file-processing.org is the template file.
      Works perfectly!!
    - State "STARTED"    from ""           [2017-01-06 Fri 15:08]
      Already have many thinkings, writting many notes.
**** doc
     - headlines selection:
       - if it is a leaf entry, then just expand its contents. if a variable has no binding, look backword for that variable. if not exists in every parents, then prompt the user for value.
       - else, all the children entrys will be expanded. The variable resolving method is the same.
       - so, the tree structure of all entrys is important.
       THink: should headlines should be merged for selection? =>We can  mergeed to see the effect at first.
     - then shortcut is not needed.
        
     This idea is great 
     
     On implementation:
     1. we should get all variable names in the snippet contents. So that we can prompt the user for value it it not exists in env(and parent env).
        Maybe we can use a new syntax for this. such as %var-name, and %(var-name default-value), and %(var-name value1 value2 ), and %(var-name (value1-display value1-real) (value2-diaply value2-real)), that is,  the same format as the original header. And here support variable reference will be easy, just compile %(var1 $ref) to `ref` instead of `var1`.
        
        In fact just embbed the original header in the contents. 
        The new syntax will be compiled to `var-name` syntax and expand-env before passed to yas-expand-snippet.
        So we only need to compile this format to the current format.
        
        Why not just use $var-name? =>we want preserve the old syntax for local selection/input.
        Why not just use `var-name` => we want have default value
        
        The finally effects is: 
        1. writtig snippet is just the same as method provided by yasnippet, but with new syntax added(the % syntax).
           
        2. specify snippets hierachy / relationship by org entry tree.
           - Each entry is a snippet of all the children's snippets.
           - child entry can inheritate env variable from parent entry.
           - *BUT* sometimes not all children should be included. On one condition, include this child, but on anothe condition, include that child. The decision is decided by a env variable of the parent. 
             => I think this can be fixed by a annotation named precondition:  @(precondition (var1 value11 value12) (var2 value21))
             This snippet will be included only when var1 equals value11 or value12, and var2 equals value21.
             Dynamic binding is great!! seems Fixed.
             
             Another problem:
             Some snippets should be seperated to two parts. How to resolve this? by tree structure, seems not good. 
             => this problems can be fixed by simplely following this rule: all the following siblings of an entry will be placed at $0 of this entry's snippets. Perfectly fixed!!
             
             
     according above rules,  I rewrite the java file processing snippet file:
     c:/Users/luooofuq/Dropbox/project/aspk-new-snippet/snippets/java-mode/file-processing.org
     
     Some findings:
         1. when expand an entry, two parameters should be passed:
            1. the caller, by parent entry or by end user
            2. the env variables.
               The env saves all possiable values for all defined and referenced variables. This should be uniform for both callers.  
               By for parent entry caller, the variables who already have values should only have this exact value in the env, instead of all possiable values.
               Then the codes can process in the same way.
         2. with the new methods, this var is shared easily by many snippets
            @(vars (for  (read "Input") (write "Output")))
         3. embedded variable definiton syntax
            `var-name value1 value2 (value3-display value3-real) value4`
            Only one variable can be defined with this syntax.
         4. formal variable definiton syntax
            @(vars (var1-name value1 value2 (value3-display value3-real) value4)  var2-name  ...)
            Many variables can be defined with this syntax. The var1-name is the same as the above var-name.
         5. Notes on the two variable definition syntax
            They have the same effects in perspective of variable creation and value getting. 
            The difference is that for embedded syntax, the var-name will be included in the snippets content, while for formal syntax, it will be removed from snippets content.
            The below two are exactly the same:
            #+name: formal syntax
            #+BEGIN_SRC perl
            @(vars (file-name "aaa.txt"))
            open my $fh, "<", `file-name`;
            #+END_SRC

            #+name: embedded syntax
            #+BEGIN_SRC perl
            open my $fh, "<", `file-name "aaa.txt"`;
            #+END_SRC

            Most time we will use embedded syntax since it is convienint.
         6. the if annotation works like an if statement, used for check precondition is fullfilled.
             @(if (for write))
            Currently we only support if one variable value is some value, but we don't support one variable value is not some value. Do we need this? 
            => We can add a new annotation @(unless) to express this when we need this.
            There can be many if statements within one single template text.
        
        Seems this way is perfect!! without any pitfalls. great!!

            
        About the structure:
        - template: assoc list of below element. Represent an org mode file entry.
          - name: string. this is the head line of the entry
          - defined variables(var-table): list of list of variable name and their possiable values.
            All variables defined, either formlly by @(vars) annotation, or by embedded syntax `var value`.
            Order is respected.
          - hungry variables(hungry-vars): list of variable names, which is a string. This is the variables that need getting value, either form env, or end user.
            either specified by @(get) annotation, or by embedded syntax `var value`.
            Order is respected.
          - precondition variables(precondition-table): assoc list of ((equal . (A)) (notequal . (A))), A: list of (var value).
            in two parts: equal and not equal, either specified by @(if ) or @(unless).
            Order is respected.
          - text: string. This is the content passed to yas-expand-snippet.
            with all annotation and embedded syntax removed.
          - children: list of template
            Nil if this is a leaf entry.
          - parent: template.
            Nil if this is a root entry.

       How to expand a snippet:
       Praemter:
       1. the template that to be expanded:template
       2. [optional]already filled variables: list of list of (varname  value)
       3. [optional]caller: symbol of parent or user.
          
       Processing steps:
       1. prepare the variable value pool, which specify all possiable values for a variable, is a list of all element of parent's defined variables.
          Seems this step only need be done once. and saved in the env field of a template. =>can be done on the fly and memorized.
       2. If caller is nil:
          if filledVariables is nil, set caller to 'user,
          else set caller to 'parent.
       3. check the precondition 
          if failed , return
       4. get values for hungry variables.
          First search in the already filled variables, then from user.
       5. put this variable to already filled variables.
       6. call yas-expand-snippet to expand the snippet, pass the text, and already filled variables.
       7. process children. For each child, repeat step 1~7.
          Note: already filled variables should be the same for all siblings. This makes sure no polution for each other.

      Nother notes: may be we can concat all text part of a template, and its children, and only call yas-expand-snippet for only one time.
      Or we can just make yas-expand-snippet a implementation to a virtual function of expand-snippet.


      On the variable syntax:
      (var-name value1 (value2-display value2-real) :doc "doc to this variable" value3 :reference var2)
      use ':key value' pair to express propertys of the variable.
**** codes
     Get the src block tree, Just reuse the old codes.
     #+NAME: no-name
     #+begin_src elisp
     (setq file (expand-file-name "./snippets/java-mode/file-processing.org"))

     ;; get all src block in file
     (setq a (pns-get-all-src-blocks file))
     (setq b (pns-convert-block-list-to-tree a))
     ;; b now is the tree

     (defun pns-print-tree-1 (tree)
       ;; (message "Tree: %s" tree)
       (message "level: %s, heading: %s"
                (pns-assoc 'level tree)
                (pns-assoc 'heading tree))
       (mapc (lambda (tt)
               (if (listp tt)
                   (pns-print-tree-1 tt))
               )
             (pns-assoc 'children tree)))


     (progn
       (message "######### Tree Start ############")
       (pns-print-tree-1 b)

       (message "######### Tree End ############")
       nil)

     #+end_src
     
     parse src block tree node's content part.
     #+NAME: methods
     #+begin_src elisp
     ;; src = annotation + text-src
     ;; text = replace `var value` syntax with `var` in text-src
     (defun pns-src-parser (src)
       "Convert src, which is the src block's content, to a assoc list of some fields of templates: var-table, hungry-vars, precondition-table, text"
       ;; (message "src: %s" src)
       (let (hungry-vars hungry-vars1 var-table var-table1 precondition-table text)
         (multiple-value-setq
             ;; annotation is a list of (annotaton-name value), the same part after @.
             ;; text-src is the remaining src, where all `var value` syntax will be inspected.
             (annotations text-src)
           (pns-src-parser--consume-annotation src))

         (multiple-value-setq
             ;; hungry-vars is the vars of get annotation
             ;; precondition-table is the vars of if annotation
             (hungry-vars precondition-table var-table)
           (pns-src-parser--parse-annotation annotations))

         (multiple-value-setq
             (hungry-vars1 var-table1 text)
           (pns-src-parser--parse-text text-src))

         `((var-table . ,(append var-table var-table1))
           (hungry-vars . ,(append hungry-vars hungry-vars1))
           (precondition-table . ,precondition-table)
           (text . ,text))))

     (defun pns-src-parser--consume-annotation (src)
       (let (rst text-src (last-point 1))
         (condition-case *error-info*
             (progn
               (and (get-buffer " myTemp") (kill-buffer " myTemp"))
               (set-buffer (get-buffer-create " myTemp"))
               (insert src))
           (error
            (message "Error happened: %S" *error-info*)
            (debug *error-info*)
            (list "Error: Fail to get snippet name. Error info below" *error-info*)))

         (goto-char (point-min))
         (while (re-search-forward "^\s*[^\\]?@\\(.*\\)$" (point-max) t)
           (match-string 1)
           ;; here (match-string 1) is the matched text by first (), add processing codes here
           ;; (message "Matched string %S" (match-string 1))
           (add-to-list 'rst (read (match-string 1)) 'append)
           (setq last-point (match-end 0))
           )
         (setq text-src (buffer-substring-no-properties last-point (point-max)))
         (kill-buffer " myTemp")
         (list rst text-src)))


     (defun pns-src-parser--parse-annotation (annotations)
       (let (hungry-vars precondition-table var-table)
         (mapc
          (lambda (elem)
            ;; (message "elem=%s" elem)
            (cond ((equal (car elem) 'get)
                   (setq hungry-vars (append hungry-vars (cdr elem))))
                  ((equal (car elem) 'if)
                   (setq precondition-table (append precondition-table (cdr elem))))
                  ((equal (car elem) 'vars)
                   (setq var-table (append var-table (cdr elem))))
                  (t (error "Unsupported annotation: %S" elem))))
          annotations
          )
         (list hungry-vars precondition-table var-table)))

     (defun pns-src-parser--parse-text (text-src)
       (let (hungry-vars var-table rst text tmp)
         (condition-case *error-info*
             (progn
               (and (get-buffer " myTemp") (kill-buffer " myTemp"))
               (set-buffer (get-buffer-create " myTemp"))
               (insert text-src))
           (error
            (message "Error happened: %S" *error-info*)
            (debug *error-info*)
            (list "Error: Fail to get snippet name. Error info below" *error-info*)))

         (goto-char (point-min))
         (while (re-search-forward "`\\([^`]+\\)`" (point-max) t)
           ;; (while (re-search-forward "" (point-max) t)
           (match-string 1)
           ;; here (match-string 1) is the matched text by first (), add processing codes here
           (message "Matched string %S" (match-string 1))
           (setq tmp (read (format "(%s)" (match-string 1))))
           (add-to-list 'rst tmp 'append)
           (replace-match (format "`%s`" (car tmp)))
           )
         (setq text (buffer-substring-no-properties (point-min) (point-max)))
         (kill-buffer " myTemp")
         (setq hungry-vars (mapcar (lambda (x) (car x)) rst))
         (setq var-table (delete nil
                                 (mapcar (lambda (x)
                                           (when (> (length x) 1)
                                             x)) rst)))
         (list hungry-vars var-table text)))


     #+end_src
     
     So for this src:
     #+NAME: test-pns-src-parser-input
     #+begin_src elisp
     "@(get method)
     @(if (method allocate allocateDirect))
     `type`Buffer buffer = `type`Buffer.`method`(`size 1024`);"
     #+end_src
     
     The result of pns-src-parser is:
     #+NAME: test-pns-src-parser-result
     #+begin_src elisp
     (
      (var-table (size 1024)) ;;because type and method don't have possiable values, so don't put them in var-table. Then we ensure the variable resolving rule.
      (hungry-vars method type size) ;;Note method is the first hungry var, because it is defined by @(get method), and this line is the first line in src
      (precondition-table (method allocate allocateDirect))
      (text . "`type`Buffer buffer = `type`Buffer.`method`(`size`);")
      )
     #+end_src
     
     Some test codes:
     #+NAME: no-name
     #+begin_src elisp
     (setq aa      "@(get method)
               @(if (method allocate allocateDirect))
          @(vars xxx)
          @(get type)
          @(vars (for (read <) (write >)))
               `type`Buffer buffer = `type`Buffer.`method`(`size 1024`);"
           )

     (setq bb (pns-src-parser--consume-annotation aa))(setq cc (pns-src-parser--parse-annotation (car bb)))


     ;; (pns-src-parser--parse-text "`type`Buffer buffer = `type`Buffer.`method`(`size 1024`);")
     (pns-src-parser--parse-text (nth 1 bb))

     (setq dd (pns-src-parser aa))



     (defun pns-print-tree-2 (tree)
       ;; (message "Tree: %s" tree)
       (message "level: %s, heading: %s"
                (pns-assoc 'level tree)
                (pns-assoc 'heading tree))
       (when (pns-assoc 'content tree)
         (message "src paser result: %S" (pns-src-parser (pns-assoc 'content tree))))
       (mapc (lambda (tt)
               (if (listp tt)
                   (pns-print-tree-2 tt))
               )
             (pns-assoc 'children tree)))

     (pns-print-tree-2 b)
     #+end_src
     pns-src-parser works correctly for all srcs in the java-mode/file-processing file. Great!!!
     
     
     Processing template, selecting with helm...
     #+NAME: methods
     #+begin_src elisp
     (defun pns-convert-input-tree-to-template-tree (tree &optional parent)
       "change the 'content to a src parser. return a template, which is a tree."
       ;; *Important*: rst should have dynamic value, or it will alwasy get the old addresss.
       (let ((rst (list '(i-am-root . t) '(name . "root")
                        (cons 'dummy ;; create a number string with length 16
                              (replace-regexp-in-string " " "0" (format "%16s" (random 10000000000000000)))))))
         (when (pns-assoc 'content tree)
           (setq rst (pns-src-parser (pns-assoc 'content tree)))
           (push (cons 'parent parent) rst)
           (push (cons 'name (pns-assoc 'heading tree)) rst))
         ;; (tracee rst)
         (setcdr rst (append  (cdr rst)
                              (list (cons 'children
                                          (delete nil
                                                  (mapcar (lambda (tt)
                                                            ;; (tracee tt)
                                                            (if (listp tt)
                                                                (pns-change-tree tt rst)))
                                                          (pns-assoc 'children tree)))))))
         rst))


     (defun pns-print-template-tree (tree &optional height)
       "This print a tree in a nice format"
       (or height (setq height 0))
       (let ((msg-func (lambda (info &rest args)
                         (apply 'message (cons (format "%s%s" (make-string height ? ) info) args))))
             tmp)

         (funcall msg-func "--------------------")
         (mapc (lambda (field)
                 (when (pns-assoc field tree)
                   (setq tmp (pns-assoc field tree))
                   (when (stringp tmp) (setq tmp (replace-regexp-in-string "\n" "\\\\n" tmp)))
                   (funcall msg-func "%s: %S" field tmp)
                   ))
               '(name hungry-vars var-table precondition-table text))

         (mapc (lambda (tt)
                 (pns-print-template-tree tt (+ 4 height)))
               (pns-assoc 'children tree)))
       nil)


     (defun pns-create-template-new (file)
       "create template(which is a tree) given FILE, which is an org mode template file"
       (let ((tree (pns-convert-input-tree-to-template-tree (pns-convert-block-list-to-tree (pns-get-all-src-blocks file)))))
         tree))

     (defun pns-create-template-table (template &optional rst)
       "Create a name to template object table, given template. Key is name, value is template. this table can be used as helm candidates"
       (let (aaa)
         (unless (assoc 'i-am-root template)
           (setq rst (append (list (cons (pns-assoc 'name template) template)) rst)))
         (mapc (lambda (tt)
                 (setq rst (pns-create-template-table tt rst)))
               (pns-assoc 'children template)))
       rst)

     (defun pns-get-var-table (template)
       "Get the var table for the template, with parent's var table mergetd"
       (let ((rst (pns-assoc 'var-table template))
             (parent (pns-assoc 'parent template)))
         (while parent
           (message "parent name: %S" (pns-assoc 'name parent))
           (setq rst (append (pns-assoc 'var-table parent) rst))
           (setq parent (pns-assoc 'parent parent)))
         (reverse rst)))

     (defun pns-get-hungry-values (template &optional filled-vars)
       "Get hungry for a template. Return a list of list of varname and value, (var-symbol value)"
       (let ((hungry-vars (pns-assoc 'hungry-vars template))
             (var-table (pns-get-var-table template))
             possiable-values)
         (mapcar (lambda (var)
                   ;; change (read "Input") to (read . "Input")
                   (setq possiable-values (mapcar (lambda (elem)
                                                    (if (listp elem)
                                                        (cons (nth 0 elem) (nth 1 elem))
                                                      elem))
                                                  (pns-assoc var var-table)))
                   ;; (message "var: %S, possiable-values: %S" var possiable-values)
                   (message "## Getting value for hungry var %s" var)
                   (list var
                         (cond
                          ;; first search in filled-vars
                          ((assoc var filled-vars) (nth 1 (assoc var filled-vars)))
                          ;; get from helm
                          ((> (length possiable-values) 1)
                           (helm-other-buffer
                            `(((name . ,(format "%s" var))
                               (candidates . ,possiable-values)
                               (action . (lambda (c ) c))
                               (accept-empty . t)))
                            (pns-assoc 'name template)))
                          ;; get by read-string
                          ((>= (length possiable-values) 0)
                           (save-excursion (read-string (format "%s. %s[%s]: "
                                                                (pns-assoc 'name template)
                                                                var (or (car possiable-values) "")) nil nil (car possiable-values))))
                          (t (error "Impossible to be here")))))
                 hungry-vars)))


     (defun pns-get-real-value-for-var (var-name display-value template)
       "Get real value for var with display-value"
       (let* ((var-table (pns-get-var-table template))
              (var-values (pns-assoc var-name var-table))
              (rst display-value))
         (mapc (lambda (value)
                 (when (and (listp value) (equal display-value (car value)))
                   (setq rst (nth 1 value))))
               var-values)
         (message "Get real value for var $S with display-value %S: %S" var-name display-value rst)
         rst))

     (defun pns-expand-tempalte (template &optional filled-vars caller)
       "Expand a template, recursively."
       (interactive)
       (or caller
           (setq caller (if filled-vars 'parent 'user)))

       (let (hungry-vars text (check-passed t) (var-table (pns-get-var-table template)))
         (pns-print-template-tree template)
         (message "Filled-Vars: %S" filled-vars)
         (message "Expanding %s" (pns-assoc 'name template))

         ;; check precondition
         (when (equal caller 'parent)
           (mapc (lambda (var-value)
                   (let* ((name (car var-value))
                          (expected-values
                           (mapcar (lambda (elem)
                                     ;; elem is the display value symbol for var name.
                                     ;; convert from display to real
                                     ;;convert symbol to string
                                     (format "%s" (pns-get-real-value-for-var name elem template))
                                     )
                                   (cdr var-value)))
                          (real (car (pns-assoc name filled-vars))))
                     (unless (member real expected-values)
                       (setq check-passed nil)
                       (message "Precondition checking not pass for name: %s. Expected: %s, real: %s"
                                name expected-values real))))
                 (pns-assoc 'precondition-table template)))

         (when check-passed
           (setq text (pns-assoc 'text template))
           (setq hungry-vars (pns-get-hungry-values template filled-vars))
           ;; (message "%S, %S, %d, buffer: %S" text hungry-vars (point) (current-buffer))
           ;; expand this
           (yas-expand-snippet  text (point) (point) hungry-vars)

           ;; expand all children
           (mapc (lambda (tmpl)
                   (pns-expand-tempalte tmpl hungry-vars 'parent))
                 (pns-assoc 'children template))))
       (message "Done"))


     (setq pns-template-file (expand-file-name "./snippets/java-mode/file-processing.org"))
     (defun pns-expand-template-by-name ()
       "Use helm select which template to be expanded, based on its name. The input is a global variable pns-template-file saving the template file name."
       (interactive)
       (let ((template
              (save-excursion
                (helm-other-buffer
                 `(((name . "Template")
                    (candidates . ,(pns-create-template-table (pns-create-templates-new pns-template-file)))
                    (action . (lambda (template )
                                template))
                    (accept-empty . t)))
                 "Template"))))
         (pns-expand-tempalte template)))
     #+end_src
     
     Test codes of above:
     #+NAME: no-name
     #+begin_src elisp
     (setq file (expand-file-name "./snippets/java-mode/file-processing.org"))

     (setq dd (pns-convert-input-tree-to-template-tree b nil))

     (pns-print-template-tree dd)

     (pns-print-template-tree (pns-create-templates-new file))

     (setq aa (pns-create-templates-new file))

     (setq bb (pns-create-template-table aa))

     (setq pns-src-parser-input-file "/Users/astropeak/Dropbox/project/aspk-new-snippet/snippets/java-mode/file-processing.org")
     #+end_src

     
** run
   - Note taken on [2017-01-06 Fri 21:23]
   First run pns-create-modules-run to generate pns-modules. This will searching all files under pns-snippet-dir, each file should have two entries: '* snippet: xxx' and '* shortcut: yyy', or there will be an error.
   Then run pns-main-module to select a snippet.

   The old method, also applicable.
   First run pns-main-1 to generate pns-templates from pns-snippet-file
   Then run pns-main to do the interactive selection and it will generates the code.
   
** programming notes
*** throw errors guard correctness, detect fault in development stage
    Then when error happens, the program stops at that place, debugging will be much easy.
*** write test for each function
    This helps understand the function. and also a regretion test.
*** use uniform data format. If not the same, first convert to the same
    This will greatly reduce complexsity of codes. 
    
    In this project, the parameter has tow form:
    (key value) and (key (display-value real-value)).
    
    So there are lots of codes that handle the difference of those tow froms.
    
    Good way is: first convert to uniform format before processing.  This applys in many places.
*** input-parser: a program should have a uniform/stable internal format for representing the input data
    Then we can change the original input format easily, just write a new input parser.
    
    In this project, the input data is an org mode file. The internal format is a lists of template.
    We can easily change the input date to a string, or a list, just write a new parser for that data format.
    
    We can name this function as xxx-input-parser, it accepts one type of input data, and always return the internal input format. The xxx-input-parser function call different coolier functions to process input data, based on their type.
*** emacs lisp global variable, and funtion interface design
    the -contains? function from dash package don't add a third parameter, but it use a global variable -compare-fn to used as compare function.
    Since emacs list is dynamic binding, so we can use this idiom to express this without change the global value of '-comare-fn' value:
    #+NAME: no-name
    #+begin_src elisp :results value
    (let ((-compare-fn (lambda (a b) (equal (+ 1 a) b))))
      (-contains? '(1 2 3) 2)
      )
    ;; and here -contains-fn still its original value.
    #+end_src
    
    This teckniques are used common when search regexp:
    #+NAME: no-name
    #+begin_src elisp
    (let* (
           (name "\\(header\\|content\\)")
           (case-fold-search t)  ;; makes the searching ignore case
           (regexp (concat org-babel-src-name-regexp name "[ \t(]*[\r\n]\\(?:^#.*[\r\n]\\)*"
                           (substring org-babel-src-block-regexp 1))))
      (re-search-forward regexp nil t))

    #+end_src
    
    -contains? documents
    #+BEGIN_SRC text
    -contains? (list element)

Return non-nil if list contains element.

The test for equality is done with equal, or with -compare-fn if that's non-nil.

Alias: -contains-p

(-contains? '(1 2 3) 1) ;; => t
(-contains? '(1 2 3) 2) ;; => t
(-contains? '(1 2 3) 4) ;; => nil

    #+END_SRC
*** annotation is a great way for adding syntax to a existing grammer
    I use annotation to add below syntaxs to org mode file grammer:
    1. define variables formally
    2. the if statement
    3. get variable value

*** create a unique name for every concepts, things, and there relationships
    This will make programming very clear!!!
    
** doc
*** Three main part of the program
    1. get parameters from user by helm or read-string. Done by pns-prompt-for-header.
       The input is pns-templates(now it is a global variable), but only the header part is needed.
       
       What this fucntion done is given a list of headers, let user select parameter values if there are multiple, and finally return one unique header.
       A header can be wrtten in a relative flexible way.
       
       The output is a list of cons of (key . value). The key is variable names in the snippet, the value is its value.
       an example: pns.el:pns-do-expand:157:	header=(("command" . "create-channel") ("for" . "read") ("part" . "part1") ("file-name" . "\"aaa.b\""))
    2. expand a snippet by yas-expand-snippet
       Definition:  a snippet is the content part of a template.
       
       The input is a header.
       pns-templates defines relationship between a header and a snippet. Given a header, there will be one snippet. and the header is the expand-env.
       
       The output or result:
       the snippet inserted on current buffer, current position.
    3. parse a template file, done by pns-main-update
       Definition: a template file is an org file with an entry tree, whose first level entry's headline starated with pns-snippet-entry-regexp. 
       Input is a template file, specified by pns-snippet-file.
       Output is pns-templates
       
       Each entry in a template file may contains two src blocks named 'header' or 'content'.
       All 'header' src blocks from the root entry to any leaf entry(included) forms one header element, the same apllys for 'content' src blocks. And this header and content elements combined.
       
       
    pns-do-expand integrate part 1 and part2.
*** relationship
    |--------+-----------+------------------+---------+-------------------+---------------------------|
    | module | templates | list of template | header  | list of parameter |                           |
    |        |           |                  | content | :string           |                           |
    |        | shortcuts | list of shortcut | name    | :string           |                           |
    |        |           |                  | filter  | list of header    | header with default value |
    |        | name      | :string          |         |                   |                           |
    Note: the table looks unaligned because 'space' is narrow than a letter.
    
    A shortcut is a way to 1: provide default values to parametes in a header, then those parameters will not be prompted. 2: combine many templates.
    
    a shortcut with empty filter let user select all possible template. The name should be "details".
    
    One snippet file is one module, a module's name property is used to selected by helm. then we call pns-main-shortcut.
*** parameter format
    Maybe its better to use struct to express a parameter.
    
    The parameter struct definition. Use struct is it can be extented easily.
    #+NAME: no-name
    #+begin_src elisp
    (defstruct pns-value
      display
      real
      )

    (defstruct pns-parameter
      key 
      values  ;; a list of pns-value
      doc
      default-value
      reference ;; the referenced variabled string name
      not-prompt-p ;; should this parameter not be prompted. in case this in only used as variable referenced by other elements.
      )

    (setq a (make-pns-parameter :key "command" :default-value "aaaaa"))

    (pns-parameter-default-value a)

    #+end_src
    
**** the new parser
     #+NAME: vars-hatch
     #+begin_src elisp
     (setq pns-token-reference "\\$")
     (setq pns-token-default-value "=")
     (setq pns-token-doc "@")
     #+end_src
     
     #+NAME: methods-hatch
     #+begin_src elisp :results output
     (defun pns-parse-parameter (parameter)
       "parse a parameter to the pns-parameter struct. The parameter is read form the snippet file, are a list of symbols"
       ;; a input parameter is in this format:
       ;; 1. (key value)
       ;; 2. (key (display-value real-value) )
       ;; an element may be a symbol, or a string, and there are special elemnt, which start with a special character.
       (let (para elem pp)

         ;; convert all to string
         (setq para
               (mapcar (lambda (element)
                         (cond ((stringp element) (format "\"%s\"" element))
                               ((symbolp element) (format "%s" element))
                               ((listp element)
                                (mapcar (lambda (elem)
                                          (cond ((stringp elem) (format "\"%s\"" elem))
                                                ((symbolp elem) (format "%s" elem))
                                                (t (error "Elem type wrong: %S" elem))))
                                        element)
                                )
                               (t (error "Parameter's element type wrong, only symbol or string accepted: %S" element))))
                       parameter))

         ;; make pns-parameter
         (setq pp (make-pns-parameter))
         (setf (pns-parameter-key pp) (pop para))
         (tracee pp)
         (unless (pns-parameter-key pp)
           (error "Parameter is nil: %S" para))

         (while para
           (setq elem (pop para))
           (tracee elem)
           (cond
            ;; parse values
            ((listp elem)
             (setf (pns-parameter-values pp) (append (list (cons (nth 0 elem) (nth 1 elem))) (pns-parameter-values pp))))

            ;; BUG: if $ not at the begining, still matched.
            ;; parse doc
            ((and (stringp elem) (string-match pns-token-doc elem))
             (setf (pns-parameter-doc pp) (substring elem 1)))

            ;; parse reference
            ((and (stringp elem) (string-match pns-token-reference elem))
             (setf (pns-parameter-reference pp) (substring elem 1)))

            ;; parse default-value
            ((and (stringp elem) (string-match pns-token-default-value elem))
             (setf (pns-parameter-default-value pp) (substring elem 1)))

            (t (message "here")
               (unless (stringp elem) (error "Element is not string: %S" elem))
               (setf (pns-parameter-values pp) (append (list (cons elem elem)) (pns-parameter-values pp))))
            )
           )
         (tracee pp)
         pp))

     (defun pns-parse-header (header)
       (mapcar (lambda (parameter)
                 (pns-parse-parameter parameter))
               header))

     (defun pns-parse-templates (templates)
       (mapcar (lambda (tmpl)
                 (pns-parse-header (pns-assoc 'header tmpl)))
               templates))

     (defun pns-do-xxx ()
       (pns-parse-templates pns-tmp-templates))

     (defun pns-format-parameter (parameter)
       (format " key: %s\n values: %s\n doc: %s\n default-value: %s\n reference: %s\n not-prompt-p: %s\n\n"
               (pns-parameter-key parameter)
               (pns-parameter-values parameter)
               (pns-parameter-doc parameter)
               (pns-parameter-default-value parameter)
               (pns-parameter-reference parameter)
               (pns-parameter-not-prompt-p parameter))
       )

     (message "%S" (mapcar (lambda (header)
                             (mapcar (lambda (parameter)
                                       (pns-format-parameter parameter))
                                     header))
                           (pns-do-xxx)))
     #+end_src
     
     
     this function convert the snippet file's src blocks tree to a the lisp repreent part. The main job is merge 'header' and 'content' src blocks.
     
     #+name: test-input 
     #+BEGIN_SRC org :disabled-tangle /tmp/pns.x.y/1.org :mkdirp yes
     ,* snippet: aaa
       ,#+name: header
       ,#+begin_src elisp
        ((g-file-name "=abc.txt") (g-file-handler =$fh))
       ,#+end_src

       aaaa

     ,** aaaaa
        ,#+name: header
        ,#+begin_src elisp
        ((command open "@open a file") (target file "@not a pipe")
         (for =write (read <) (write >) (append >>) (readwrite +>))
         (file-name $g-file-name) (file-handler $g-file-handler))
        ,#+end_src
        aaa 
        
        ,#+name: content
        ,#+begin_src perl :results output
        open my `file-handler`, `for`, `file-name` or die "Open file failed";
        ,#+end_src
        aaa
     ,** bbbbb
        ,#+name: header
        ,#+begin_src elisp
        ((command close "@close a file") (file-handler $g-file-handler))
        ,#+end_src
        aaaa 
        ,#+name: content
        ,#+begin_src perl :results output
        close `file-handler`;
        ,#+end_src

        aaaa

     #+END_SRC
        
        #+name: test-input
        #+NAME: test-methods for pns-create-templates
        #+begin_src elisp
     (setq snippet-file "/tmp/pns.x.y/1.org")

     (setq pns-tmp-header nil)
     (setq pns-tmp-templates nil)
     (pns-create-templates
      (pns-convert-block-list-to-tree (pns-get-all-src-blocks snippet-file pns-snippet-entry-regexp pns-src-block-name-regexp))
      nil nil)
     ;; the result is in pns-tmp-templates
     (message "%S" pns-tmp-templates)
        #+end_src
        
        #+RESULTS: test-methods
     : (((header (g-file-name "=abc.txt") (g-file-handler =$fh) (command open "@open a file") (target file "@not a pipe") (for =write (read <) (write >) (append >>) (readwrite +>)) (file-name $g-file-name) (file-handler $g-file-handler)) (content . "   open my `file-handler`, `for`, `file-name` or die \"Open file failed\";
     : ")) ((header (g-file-name "=abc.txt") (g-file-handler =$fh) (command close "@close a file") (file-handler $g-file-handler)) (content . "   close `file-handler`;
     : ")))
        
        
        
        
    