* pns
** inbox
*** 170101, thinking and ideas
    # -*- mode: snippet -*-
    #name : create a buffer(should not expand this)
    #expand-env : ((pcs-yas-method (helm-other-buffer '((name . "Method?") (candidates . ("allocate" "direct" "wrap")) (action . (lambda (c) c))) "Which mode "))) 
    #contributor : Astropeak
    #description : 
    #key:aaa
    this doen't work
    `(progn
    (message "mode: %S, hook: %S" yas-minor-mode post-command-hook)
    (yas-expand-snippet
    (cond ((string-equal pcs-yas-method "wrap")
    "ByteBuffer buffer = ByteBuffer.wrap(${1:array});"))))`
    
    # New method:
    many blocks, each block has a header:
    The header format: 'var-name:value-regexp, xx:yy, ...'
    The block expand rule: the only one simple rule: if the var matches the value regexp, then the block will be expanded.
    
    All expanded blocks will be merged to a single snippet, and be passed to yasnippet to do the expanding. So this kind of snippet will be compiled to a yasnippet snippet.
    # --
    
    #++ method:wrap
    ${1:type}Buffer ${2:buffer} = $1Buffer.wrap(${3:array});
    
    #++ method:allocate
    ${1:type}Buffer ${2:buffer} = $1Buffer.allocate(${3:size});
    
    #++ method:direct
    ${1:type}Buffer ${2:buffer} = $1Buffer.directAllocate(${3:size});
    
    
    the procesor will look the header for all possiable values and prompt for the user. This idea is great!!!
    more than one commands can be choosed in a pass.
    
    则学习的过程就是写模板的过程。使用模板编程时，我就全部使用的是高级概念，而不需要关注细节。比如process buffer, 这里的子项包括创建、打开、读取、写入、关闭、刷出、与数组转换、与其它类型转换 等常用操作。而这些子项都会通过提示的方式显现出来，再也不需要记那么多东西。
    
    一个var的值也可以是一个list，则所有的可选值可在一个block中指定。同时在block中需要能够获得这个var的值，也能够做一些transformation,以此将该值转换在目标中。list的元素也可是一个cons，则值也显示将分离。
    采用这种方法，多个block可被合并为一个，简化编写工作。
    缺点是依赖于这个参数的参数将不太好做了。=》可能通过定义依赖来定义一个元素的值。
    
    块的顺序会有关系，因为可以多个块会被选中。顺序通过写时保证。
    
    ## Example: for processing file
    ##command: open, read, write, close, flush
    ##type: file, pipe, socket
    ##for: read, write, append, readwrite. only applicable for command open
    
    #++ command:open, type: file, for:read
    open a file for read
    
    #++ command:open, type: pipe, for:read
    open a pipe for read
    
    
    
    #++ command:open
    close the file
*** a new snippet sample
    #+BEGIN_SRC text
    ## Example: for processing file
    ##command: open, read, write, close, flush
    ##type: file, pipe, socket
    ##for: read, write, append, readwrite. only applicable for command open

    ,#+ ((command open) (type file) (for ((read <) (write >) (append >>) (readwrite +>))))
    open my $fh, `for`, ${1:file} or dir "Open file failed";

    ,#+ command:open, type: pipe, for:read
    open my $fh, "-|", ${1:command} or dir "Open command failed";


    #+END_SRC
*** test yas-expand-snippet
    `for` will be replaced to <
    #+NAME: no-name
    #+begin_src elisp
    (yas-expand-snippet "open my $fh, \"`for-value`\", ${1:file};" (point) (point) '((for (read "<++")) (for-value (if (consp for) (cdr for) for))))

    #+end_src
*** hatch codes: given templates list, prompt for input and expand a snippet
    a template, get form the new snippet file
    #+NAME: vars 
    #+begin_src elisp
    (setq pns-templates
          '(
            ((header . (("command" . "open") ("type" . "file") ("for" . (("read" . "<") ("write" . ">") ("append" . ">>") ("readwrite" . "+>")))))
             (content . "open my $fh, '`for`', ${1:file} or dir 'Open file failed';"))

            ((header . (("command" . "open") ("type" . "pipe") ("for" . (("read" . "|-") ("write" . "-|")))))
             (content . "open my $fh, '`for`', ${1:command} or dir 'Open command failed';"))
            ))
    #+end_src
    
    
    process step:
    1. for each parameter, merge to one list for selection
    2. based on the selected result, rebuild the list, the list that not match the result should be removed.
    3. repeat step 1, process next parameter.
       
       传入一个header列表，返回所有与这个列表匹配的contents
       select-content
       #+NAME: methods
    #+begin_src elisp
    (defun pns-contains (list1 list2)
      "Both list1 and list2 are assoc list. Return true if list1 contains all elements in list2. Definition:contains: elements in list2 exists in list1. The equal functon is string-equal or ... for subelement.
    e.g. list1 is header of a template, list2 is the selected data.
    "
      ;; TODO: should I consider order? 
      (let ((rst t)
            (e1))
        (mapc (lambda (e2)
                (setq e1 (assoc (car e2) list1))
                (unless (and e1 (cond ((stringp (cdr e1))
                                       (or (string-equal (cdr e1) "nil")
                                           (string-equal (cdr e2) (cdr e1))))
                                      ;; what's the logic here? =>(cdr e1) is a assoc list, while (cdr e2) always a string or something else. If (cdr e2) exists in (cdr e1)'s key set, then it means e1 contains e2.
                                      ;; BUG here. (cdr e1) also may be a list of string.
                                      ((and (listp (cdr e1)) (listp (car (cdr e1)))) (assoc (cdr e2) (cdr e1)))
                                      ((and (listp (cdr e1)) (stringp (car (cdr e1))))
                                       (member (cdr e2) (cdr e1)))
                                      (t (error "parameter format wrong: %S" e1))))
                  (setq rst nil)))
              list2)
        rst))



    (defun pns-filter-templates (header)
      "Get all templates whose header contains parameter"
      (delete nil
              (mapcar (lambda (tmpl)
                        (when (pns-contains (cdr (assoc 'header tmpl)) header)
                          tmpl))
                      pns-templates) ))

    (defun pns-get-contents (header)
      "Get all matched template's content. Match means its header contains the parameter header"
      (mapcar (lambda (tmpl) (cdr (assoc 'content tmpl)))
              (pns-filter-templates header)))


    #+end_src
    
    #+RESULTS: select-content
    | open my $fh, '`for`', ${1:file} or dir 'Open file failed'; |
    
    #+NAME: test-get-contents
    #+begin_src elisp
        (pns-get-contents '())

        (pns-get-contents '(("command" . "open")  ("for" . "read")))

        (pns-get-contents '(("type" . "file") ))

        (pns-get-contents '(("command" . "open") ("type" . "file") ("for" . "read")))

    #+end_src
    
    get header element value list
    #+NAME: methods
    #+begin_src elisp
    (defun pns-get-header-element-values (header-element-name &optional header-filter)
      "Get all values of a header element given its name, as a list. A name e.g. type, for, command. `header-filter' is a filter to filter the pns-templates before get."
      (unless header-filter (setq header-filter '()))
      (delete-dups
       (let ((rst nil))
         (mapc (lambda (tmpl)
                 (let* ((header (cdr (assoc 'header tmpl)))
                        (elem (assoc header-element-name header))
                        (value (and elem (cdr elem))))
                   (and value (cond ((stringp value) (setq rst (append rst (list value))))
                                    ((listp value)
                                     (setq rst (append
                                                rst (mapcar (lambda (ee)
                                                              (if (listp ee) (car ee) ee))
                                                            value))))))))
               (pns-filter-templates header-filter))
         rst)))

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    (pns-get-header-element-values "for" '(("type" . "file")))
    #+end_src
    
    
    #+NAME: vars
    #+begin_src elisp
    ;; a list of header element names that we will get value
    (setq pns-header-names '("command" "type" "for"))
    #+end_src
    
    The basic functions ready, now built the app.
    #+NAME: methods
    #+begin_src elisp
    (defun  pns-prompt-for-header () 
      "Prompt for each parameter. Assumption: in the filtered templates, only one parameter key exists at pos idx. Not checked if there are two, but will use the first one silently. Snippet file should ensule this."
      (let ((filter-header nil)
            (templates t) (runp t)
            first-header key values tmp input
            (idx 0) rst)
        (while runp
          (setq templates (pns-filter-templates filter-header))
          (unless templates (error "template nil. filter-header: %S" filter-header))
          (when  templates
            (setq first-header (pns-assoc 'header (car templates)))
            (setq key (car (nth idx first-header)))
            (unless key (setq runp nil))
            (when key
              (incf idx)
              (tracel first-header key idx)
              (setq values (pns-get-header-element-values key filter-header))
              (if (= (length values) 1)
                  (progn
                    (setq tmp (car values))
                    (setq input (car values))
                    (when (string-equal (car values) "nil")
                      ;; prompt for this key by read-string if (car vallues) is "nil"
                      (setq input (read-string (format "%s: " key)))
                      ))
                ;;>1. prompt for this key by helm
                (setq input (helm-other-buffer `((name . ,key) (candidates . ,values)
                                                 (action . (lambda (c) c)))
                                               "Select"))
                (setq tmp input))
              (push (cons key tmp) filter-header)
              ;; this is the result
              (push (cons key input) rst)
              )
            ))
        (reverse rst)))

    (defun pns-prompt-for-header-old (header-names)
      "Based on the templates, prompt for each parameters"
      (let ((headers))
        (mapcar (lambda (key)
                  (let ((values (pns-get-header-element-values key headers))
                        tmp)
                    (tracel values)
                    (if (= (length values) 1)
                        (if (and (stringp (car values)) (string-equal (car values) "nil"))
                            (setq tmp (read-string (format "%s: " key)))
                          (setq tmp (car values)))
                      (setq tmp (helm-other-buffer `((name . ,key) (candidates . ,values)
                                                     (action . (lambda (c) c)))
                                                   "Select")))
                    (tracel key tmp)
                    (push (cons key tmp) headers)
                    (cons key tmp)))
                header-names)))

    (defun pns-create-expand-env (header)
      "Convert header to a expand-env that can be passed to yas-expand-snippet. header is a list, element is (key . value), both key and value are strings."
      (let (tmp tmp1)
        (mapcar (lambda (elem)
                  (setq tmp (cdr (assoc (car elem) (cdr (assoc 'header tmpl)))))
                  (if (listp tmp)
                      (mapc (lambda (vv)
                              (if (consp vv)
                                  (when (string-equal (cdr elem) (car vv))
                                    (setq tmp1 (cdr vv)))
                                (setq tmp1 vv)))
                            tmp)
                    (if (and (stringp tmp) (string-equal tmp "nil"))
                        (setq tmp1 (cdr elem))
                      (setq tmp1 tmp)))

                  (tracel elem tmp tmp1)
                  ;; elem: ("command" . "open"), tmp: "open", tmp1: "open"
                  ;; elem: ("type" . "file"), tmp: "file", tmp1: "file"
                  ;; elem: ("for" . "read"), tmp: (("read" . "<") ("write" . ">") ("append" . ">>") ("readwrite" . "+>")), tmp1: "+>"
                  (list (intern (car elem)) tmp1))
                header)))

    (defun pns-do-expand (header-names)
      "given header element list, expand a snippet."
      (let* ((header (pns-prompt-for-header))
             (templates (pns-filter-templates header)))
        (tracel header)
        (mapc (lambda (tmpl)
                (yas-expand-snippet (cdr (assoc 'content tmpl)) (point) (point)
                                    (pns-create-expand-env header)))
              templates)))

    (defun pns-main ()
      (interactive)
      (pns-do-expand pns-header-names))
    #+end_src
    
    #+RESULTS: methods
    : pns-main
    
    
    #+NAME: test-
    #+begin_src elisp
    (pns-prompt-for-header)
    (pns-get-contents (pns-prompt-for-header))
    (pns-do-expand pns-header-names)
    #+end_src
    
*** ideas
    header的各个元素中，每个元素之间是有关系的。目前采用的方式是随意组合。如第一个元素有2个值，第二元素有3个值，则所有可能取值有2x3=6种。
    但还有种情况，比如第一个元素取第1个值时，第二个元素只能取前2个值；第一个元素取第2个值时， 第二个元素只能取后两个值，则所有取值有2x2处。
    如何表示这种关系呢？使用树完全是可行的，但写起来比较复杂，也不好看。 直接指定一个元素的子节点如何？通过下标。比如(children . (0 1))。 当没有指定children时，则表示children可以取所有值。 这种其实和树的效果是一样的。
*** the nio snippet sample
    Mon Jan  2 09:44:32 2017
    写这个文件花了大约一个多小时，在写的过程中，我观察结构，思考各种可能问题，着重解决分块与组合的问题。 最终想到了一种非常巧妙的方法：使用类似org mode文件的树结构来模板。
    分块有利于模板文件的编写，修改、新增都会比较方便。组合则给进一步的封闭带来便利。这两个方面均可通过org mode文件解决。
    
    一个模板块可以wrap其它模板块。这种主义也要支持。
    
    心得： 必需得通过用例，才能有想法，完全空想，基本上什么也想不出。
    #+BEGIN_SRC text
    ## the four command are independent. To expand all of four, just expand all four step by step


    ##TODO: define a major mode: display the source codes in java format, while all lines begin with a '#' in another look. fold function.


    ##通过第一个参数选择要分别展开哪些宏。第一个参数与后面的参数有什么不同？ 不同点在于在写这个模板时，就是根据第一个参数进行区分的。？这样有没有什么限制？ 应该也可以写sub command，但在不同层级。 比如 #+ 表示第一层， #++表示第二层，#+++表示第三层。 这是文本文件表达树的最佳方式，就像是org mode一样。 通过树的结构，属性继承也会方便很多。同时，感觉没必要保持严格的顺序了，完全可以通过参数指定顺序。 这个想法也是非常牛逼啊！！树的结构，对于修改及新增都有很大的便利性。
    就使用org文件吧， 这样可以继承大量代码。


    ## #++ define global variables
    ,#++ ((buffer-types '(byte int short char long float double)))

    ## nil means the value should be provided by users.
    ,#+ ((command . create-channel) (type . (in out)) (file-name . nil))
    {
        FileOutputStream fout = null;
        try {
            fout = new FileOutputStream(${1:file});
            FileChannel fc = fout.getChannel();

    ,#+ ((command create-buffer) (type . ,buffer-types)(method . (allocate direct-allocate) (size . nil)))
            ByteBuffer buffer = ByteBuffer.allocate(${2:1024});

    ,#+ ((command create-buffer) (type . ,buffer-types)(method . wrap) (array-name . nil)))
            ByteBuffer buffer = ByteBuffer.wrap(${2:1024});

    ,#+ ((command fill-buffer) (buffer-type . ,buffer-types) (content-type . (byte[] String)))
            buffer.clear();
            // fill the buffer with contents to write to a file
            final byte message[] = { 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 };
            for (int i=0; i<message.length; ++i) {
               buffer.put( message[i] );
            }

    ## how to express: this header is dependent on create-channel, type out? I think don't try to do this, this should be ensured by the user
    ,#+ ((comand write-buffer-to-channel))
            buffer.flip();
            fc.write(buffer);
           

    ,#+ ((comand read-buffer-from-channel))
            buffer.clear();
            while (fc.read(buffer) != -1) {

    ,#+ ((command extract-buffer) (buffer-type . ,buffer-types) (content-type . (byte byte[] String)))
                //now file contents saved in buffer, add process codes here
                buffer.flip();
                 int i=0;
                 while (buffer.remaining()>0) {
                     byte b = buffer.get();
                     System.out.print((char)b);
                     i++;
                 }
                
    ,#+ ((comand read-buffer-from-channel))
                buffer.clear();
            }


    ## here type should be the same as the above ones. All vars should be shared, if only they match. A child will inheritates property from its parent. if header 1 contains header 2, then header 1 is the parent, header 2 is the child.
    ## So in below header, it will inheritates 'type' and 'file-name' property from the first one.
    ,#+ ((command . create-channel))
        } catch (FileNotFoundException ex) {
            System.out.println(ex);
        } catch (IOException ex) {
            System.out.println(ex);
        } finally {
            try {
                if (fout != null) {fout.close();}
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }
    #+END_SRC
    
    用org文件重写，效果相当好。
    #+BEGIN_SRC org
    ,* doc
    ## the four command are independent. To expand all of four, just expand all four step by step


    ##TODO: define a major mode: display the source codes in java format, while all lines begin with a '#' in another look. fold function.


    ##通过第一个参数选择要分别展开哪些宏。第一个参数与后面的参数有什么不同？ 不同点在于在写这个模板时，就是根据第一个参数进行区分的。？这样有没有什么限制？ 应该也可以写sub command，但在不同层级。 比如 #+ 表示第一层， #++表示第二层，#+++表示第三层。 这是文本文件表达树的最佳方式，就像是org mode一样。 通过树的结构，属性继承也会方便很多。同时，感觉没必要保持严格的顺序了，完全可以通过参数指定顺序。 这个想法也是非常牛逼啊！！树的结构，对于修改及新增都有很大的便利性。
    就使用org文件吧， 这样可以继承大量代码。

    ,* ((global-variables . (buffer-types '(byte int short char long float double))))
      ## *+ define global variables

    ,* snippet: process files with buffer and channel, nio package
    ,** ((command . create-channel) (type . (in out)) (file-name . nil))
      ## nil means the value should be provided by users.
    ,*** ((command2 . init)
    {
        FileOutputStream fout = null;
        try {
            fout = new FileOutputStream(${1:file});
            FileChannel fc = fout.getChannel();

    ,*** ((command2 . cleanup))
        } catch (FileNotFoundException ex) {
            System.out.println(ex);
        } catch (IOException ex) {
            System.out.println(ex);
        } finally {
            try {
                if (fout != null) {fout.close();}
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }

    ,** ((command create-buffer) (type . ,buffer-types))
    ,*** ((method . (allocate direct-allocate) (size . nil))
            ByteBuffer buffer = ByteBuffer.allocate(${2:1024});

    ,*** ((method . wrap) (array-name . nil))
            ByteBuffer buffer = ByteBuffer.wrap(${2:1024});

    ,** ((command fill-buffer) (buffer-type . ,buffer-types) (content-type . (byte[] String)))
            buffer.clear();
            // fill the buffer with contents to write to a file
            final byte message[] = { 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 };
            for (int i=0; i<message.length; ++i) {
               buffer.put( message[i] );
            }

    ## how to express: this header is dependent on create-channel, type out? I think don't try to do this, this should be ensured by the user
    ,** ((command extract-buffer) (buffer-type . ,buffer-types) (content-type . (byte byte[] String)))
                //now file contents saved in buffer, add process codes here
                buffer.flip();
                 int i=0;
                 while (buffer.remaining()>0) {
                     byte b = buffer.get();
                     System.out.print((char)b);
                     i++;
                 }
                

    ## here type should be the same as the above ones. All vars should be shared, if only they match. A child will inheritates property from its parent. if header 1 contains header 2, then header 1 is the parent, header 2 is the child.
    ## So in below header, it will inheritates 'type' and 'file-name' property from the first one.
    ,** ((command write-to-channel-from-buffer))
            buffer.flip();
            fc.write(buffer);
           
    ,** ((command read-from-channel-to-buffer))
    ,*** ((command2 part1))
            buffer.clear();
            while (fc.read(buffer) != -1) {
            // process buffer content here

    ,*** ((command2 part2))
                buffer.clear();
            }

    #+END_SRC
*** the perl processing file snippet in org mode format
    In this entry, the processing steps are described.
    
    #+BEGIN_SRC org :tangle perl-file-processing.org
    ,* ideas & docs
      - if a parameter has no value, then its value should be prompt for
        such as the '(file)' parameter.
      - maybe add a doc string to a parameter is a good idea. 
        And the doc string is optional. If it not exists, then the parameter key will be used. Angin a good idea.
        A parameter is e.g. '(command open)', 'command' is the parameter's key, 'open' is the parameter's value.
      - ((k1 v1) (k2 (v21 v22))) is the same as the two: ((k1 v1) (k2 v21)) and ((k1 v1) (k2 v22))
        We can always flatten the formmer to the latter to ease our implementation of parse the snippet. and we can make an header has uniform format by always transform it in this format: ((k1 v1 doc1) (k2 v2 doc2) ...), and k1 is always a symbol, v1 is always a cons of (key . value), doc1 is always a string of documentation of this parameter. This idea is great!! It greatly descreases the complexity of codes, for we only have one case to handle. A header is a list of parameters.
        
        When writting snippet, the latter form is better. It helps removing duplicates. But the former form also works. I love this flexibility!
      - put the header in a source block named header, put the expanded codes in a source block named content
        Currently the the header is put in the headline, then it's hard to write long headers.
      - Put the global parameters in the source block name global-definition
        And all the child entry and this entry can refer to that definition
        So just put parameters to the root entry, all the snippet can access to those.
        
        Seems the 'global-definition' and 'header' block have very small differences. The element(which is a parameter) in a 'global-definition' only has one possible value, while a 'header' can has may values. So we can use 'header' as 'global-definition'. 
        
        What we really need is global function definition. Those functions will be created and can be used in the everywhere. 
        Currently we can only support lambda functions to ease the implementation.
      - the processing steps of this file to transform it to a template list
        Note: a template is a list of ((header . H) (content . C))
        1. find the level 1 entry started with 'snippet:'
           Should have only one such entry. root-entry
        2. init current-templates to nil, current-header, current-content to nil,
           
        3. set current-entry to root-entry
           
        4. process the content of current-entry
           Note: content of an entry is the text betwwen the entry's headline and its first child entry's headline, exclusive.
           - for block named 'header', append all parameters of this header to current-header
             Note: I find no need to seperate parameter and functions, because they all server as a environment variable. And our algorithm is that we only prompt for selection or input only when a parameter has mulitple values or has no value. If it has only one value, then nothing will be done, it will server as an environment value only.
           - for block named 'content', append the content to current-content
             without adding any newline characters. So you should add new line in the block if wanted.
           - if this entry is a leaf, 
             then add ((header . current-header) (content . content)) to current-templates.
             then restore current-header and current-content to the original value.
             
           - else for all direct child entrys:
             loop with current-entry in all direct child entrys:
             repeat step 4.
             
        5. now current-templates contains all template of this snippet tree.
           
      - helm source candidate
        the level one snippet entry's headline and
        the direct child's headlines of level one shotcut entry
        will be added as helm source candidate
        
        For both candidates, the level one snippet entry will first be processed to a templates list.
        Note: maybe this can be processed at init stage and saved for latter use, and update when needed(such as the file has a newer version).
        Then for the first type of candidate, the filter will be set to '()
        for the second type of candidate, the filter will be set to source block 'filter' of that entry.
        Note: a filter is a list of parameters, and is used to give initial value to a parameter. Then that parameter will not be prompt for selction or value.
        
        
    ,* snippet: processing files, open, read, write, close
      ,#+name: header
      ,#+begin_src elisp
      ((snippet-name xxxxx))
      ,#+end_src
      
    ,** ((command open) (target file) (for ((read '<') (write '>') (append '>>') (readwrite '+>'))) (file))
       ,#+name: header
       ,#+begin_src elisp
       ((command open) (target file)
        (for (read <) (write >) (append >>) (readwrite +>))
        (file))
       ,#+end_src
       
       ,#+name: content
       ,#+begin_src perl :results output
       open my $fh, '`for`', `file` or die "Open file failed";
       ,#+end_src
       
       Notes on variable binding:
       For element type string, name, name-value, name-key all bind to the same string;
       For element type cons, name is binded to the cons, name-key will be binded to (car name), name-value will be binded to (cdr name).
       e.g.:
       if `for` is '(read '<')', `for-value` will be 'read', `for-key` will be '<'.
       if `target` is 'file', then `target-key`, `target-value` are all 'file'.
       
    ,** ((command open) (target pipe) (for ((read '|-') (write '-|'))) (command))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command open) (target pipe) (for (read |-) (write -|)) (shell-command))
       ,#+end_src
       
       ,#+name: content
       ,#+begin_src perl :results output
       open my $fh, '`for`', `shell-command` or die "Open command failed";
       ,#+end_src
       
    ,** ((command close))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command close))
       ,#+end_src
       
       
       ,#+name: content
       ,#+begin_src perl :results output
       close $fh;
       ,#+end_src
       
    ,** ((command read)  (file-handler) (to))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command read)  (file-handler) (to))
       ,#+end_src
       
    ,*** ((type line))
        ,#+name: header
        ,#+begin_src perl :results output
       ((type line))
        ,#+end_src
        
        
        read a line from a file handler
        ,#+name: content
        ,#+begin_src perl :results output
       `to` = <`file-handler`>;
        ,#+end_src
    ,*** ((type whole-content-as-string))
        ,#+name: header
        ,#+begin_src perl :results output
       ((type whole-content-as-string))
        ,#+end_src
        
        
        read the file's whole content as a string
        ,#+name: content
        ,#+begin_src perl :results output
        local $/;
        `to` = <`file-handler`>;
        ,#+end_src
        
        
    ,* shotcut
      shotcut is a way to predefine some parameters so that these parameters will not be prompted to user for value.
      
    ,** open a file for read, and then close
       This shotcut contains two header, the first one will define three element. The whole:
       ,#+NAME: filter
       ,#+begin_src elisp
       (((command open) (target file) (for read))
        ((command close)))
       ,#+end_src
       Element is a header, each element will be processed in turn.
    #+end_src
       
       
    #+END_SRC
*** hatch codes: parse org mode file to templates list
    INFO. All org mode related codes
    #+NAME: no-name
    #+begin_src elisp

(org-entry-delete)
(org-entry-beginning-position)
(org-entry-end-position)
(org-entry-get)
(org-entry-get-with-inheritance)

(org-entry-properties)
(org-entry-is-todo-p)

(defun org-in-src-block-p (&optional inside)

(org-babel-src-block-names pns-snippet-file)

(defun org-goto-first-child ()
  "Goto the first child, even if it is invisible.
Return t when a child was found.  Otherwise don't move point and
return nil."

(defun org-back-to-heading (&optional invisible-ok)
  "Call `outline-back-to-heading', but provide a better error message."

(defun org-get-next-sibling ()
  "Move to next heading of the same level, and return point.
If there is no such heading, return nil.
This is like outline-next-sibling, but invisible headings are ok."


(defun outline-next-visible-heading (arg)

(defun outline-next-heading ()
(outline-level)
(org-entry-put)
(org-find-entry-with-id)

;; get the entry text, after heading, entire subtree
(org-get-entry)

(defun org-babel-next-src-block (&optional arg)
  "Jump to the next source block.
With optional prefix argument ARG, jump forward ARG many source blocks."
  (interactive "p")
  (org-next-block arg nil org-babel-src-block-regexp))


    #+end_src
    
    #+NAME: init
    #+begin_src elisp
(require 'aspk-debug)
    #+end_src
    
    #+NAME: vars
    #+begin_src elisp
    (setq pns-snippet-file "perl-file-processing.org")
    (setq pns-snippet-entry-regexp  "^\*+\s+snippet.*")
    ;; (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp)
    #+end_src
    
    DONE. a function get all src block, (name, content, belonging-heading-level), in the same order they are defined.
    #+NAME: methods
    #+begin_src elisp
        (defun pns-get-all-src-blocks (snippet &optional entry)
          "Get all src blocks of the given snippet file name, return as a list. All src blocks should be in a entry, or there will be error. If the entry is provided, then only get that entry's src blocks. entry is regexp to match a headline "
          (let (tmp rst)
            ;; create temp buffer without undo record or font lock. (more efficient)
            ;; first space in temp buff name is necessary
            (and (get-buffer " myTemp") (kill-buffer " myTemp"))
            (set-buffer (get-buffer-create " myTemp"))
            (insert-file-contents snippet nil nil nil t)

            ;; get only the entry's content
            (when entry
              (goto-char 1)
              (if (re-search-forward entry nil t)
                  (let ((heading (match-string 0))
                        (entry (org-get-entry)))
                    (erase-buffer)
                    (insert heading)
                    (insert "\n")
                    (insert entry))
                (error "Entry %S not found." entry)))

            ;; (write-file "aaa")
            (goto-char 1)
            (while (setq tmp (pns-get-src-block-info))
              (push tmp rst))
            (prog1 (reverse rst)
              (kill-buffer " myTemp"))))

        (defun pns-get-src-block-info ()
          "Return a accoc list of block info, searching form current position, current buffer. If no src blocks, return nil, and position will not be moved.
        The codes are copied form org-babel-find-named-block "
          (interactive)
          (let* (
                 (name "\\(header\\|content\\)")
                 (case-fold-search t)
                 (regexp (concat org-babel-src-name-regexp name "[ \t(]*[\r\n]\\(?:^#.*[\r\n]\\)*"
                                 (substring org-babel-src-block-regexp 1))))

            (when (re-search-forward regexp nil t)
              (append
               ;; position: beginning and end
               (list (cons 'beginning (match-beginning 0))
                     (cons 'end (match-end 0)))
               ;; src block name, lang, content
               (let ((property-name '(nil name nil lang nil nil content)))
                 (mapcar (lambda (idx)
                           (cons (nth idx property-name) (substring-no-properties (or (match-string idx) ""))))
                         '(1 3 6)))
               ;; belonging heading and level
               (save-excursion
                 (let ((p (point)))
                   (org-back-to-heading)
                   (move-beginning-of-line 1)
                   (if (re-search-forward "^\\(\\*+\\)\s+\\(.*\\)" p t)
                       (list (cons 'level (length (match-string 1)))
                             (cons 'heading (substring-no-properties (match-string 2)))))))))))

        ;; there is a bug in regexp-quote: '\\|' will be quoted to '\\\\|'

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    (defun pns-tmp ()
      (interactive)
      (message "%s" (pns-get-src-block-info)))
    #+end_src
    
    
    convert the source blocks to templates list:
    Given src blocks, get the templates.
    #+NAME: methods
    #+begin_src elisp
    ;; add a filed: leafp
    (defun pns-assoc (key list)
      (cdr (assoc key list)))

    (defun pns-add-leafp-to-src-blocks (blocks)
      (let (elem rst)
        (while blocks
          (setq elem (car blocks))
          (setq blocks (cdr blocks))
          (if blocks
              (if (>= (pns-assoc 'level elem) (pns-assoc 'level (car blocks)))
                  (push (append (list (cons 'leafp t)) elem) rst)
                (push (append (list (cons 'leafp nil)) elem) rst))
            (push (append (list (cons 'leafp t)) elem) rst)))
        (reverse rst)))

    (defun pns-convert-block-list-to-tree (blocks)
      "Covert a block list to a tree based on level. use the children and parent property"
      (let* ((elem nil)
             (idx 0)
             ;; below line will not work, the rst will change every time. Acturally, it will be the same value the last time run
             ;; (rst '((children . (a)) (parent . nil)))
             ;; this works though
             (rst (list (list 'children idx) (list 'parent)))

             ;; parents save the current level parent block
             (parents (list rst nil nil nil nil nil nil))
             (level nil)
             (parent nil) (children nil)
             )

        (tracel elem rst parents level parent children idx)

        (while blocks
          (setq elem (car blocks))
          (setq level (pns-assoc 'level elem))
          (setq parent (nth (- level 1) parents))
          ;; (message "level: %s, parent: %s" level parent)
          ;; add 'parent' and 'children' property to this elem, add saved it to (parents level)
          ;; (message "before elem: %s" elem)
          ;; (setq elem (append elem `((children . (a)) ,(cons 'parent (list parent)))))
          (setq elem (append elem (list (list 'children (format "%s-%s" (incf idx) level))
                                        (list 'parent parent)
                                        )))
          ;; (message "after  elem: %s" elem)
          (setf (nth level parents) elem)

          ;; add this elem to parent as a child
          ;; both the above operations should be destructive.
          (setq children (pns-assoc 'children parent))
          ;; (message "before children: %S" children)
          (if children (setcdr children (append  (cdr children) (list elem)))
            (setf (assoc 'children parent) (cons 'children (list elem))))
          ;; (message "after  children: %S" children)
          ;; (message "rst: %S" rst)
          ;; (cdr nil)

          (setq blocks (cdr blocks)))
        rst))



    ;; a bug in emacs lisp: seems a list with the same symbol elemnt will has the same address.
    ;; (eq (list 'a 'b) (list 'a 'b))
    ;; After I change this line :
    ;; (setq elem (append elem `((children . (a)) ,(cons 'parent (list parent)))))
    ;; TO:
    ;; (setq elem (append elem (list (list 'children (format "%s-%s" (incf idx) level))
    ;; (list 'parent parent))))
    ;; Then the program works.

    ;; This is just waist of time!! emacs lisp's desctructive operateions are full of bug!!!! I have waste about 3 hours on this!! Fuck!!!!

    ;; Found another bug:
    ;; first time run pns-convert-block-list-to-tree, it gives good answer
    ;; then it gives double the good anwser, then triple, ...
    ;; DOn't know why
    ;; FOund the root cause:
    ;; the rst value will be not the same each time the program enter. Fuck!!
    ;; (let ((elem nil)
    ;; (rst '((children . (a)) (parent . nil)))


    (defun pns-print-tree (tree)
      ;; (message "Tree: %s" tree)
      (message "level: %s, name: %s"
               (pns-assoc 'level tree)
               (pns-assoc 'name tree))
      (mapc (lambda (tt)
              (if (listp tt)
                  (pns-print-tree tt))
              )
            (pns-assoc 'children tree)))


    ;; Now the function works!!!
    (defun pns-create-templates (block-tree c-header c-content)
      "Assue content block is behind of header block or it will be error."
      (tracel c-header)
      (let ((name (pns-assoc 'name block-tree))
            (children (pns-assoc 'children block-tree)))
        ;; (message "lenth children=%s" (length children))
        (if (= (length children) 1)
            ;;this is a leaf
            (cond ((string-equal name "header")
                   (setq pns-tmp-header c-header))
                  ((string-equal name "content")
                   (add-to-list 'pns-tmp-templates
                                (list (cons 'header pns-tmp-header) (cons 'content c-content))
                                t)))
          ;; this is a parent
          (mapc (lambda (tt)
                  (when (listp tt)
                    (let ((name (pns-assoc 'name tt))
                          (content (pns-assoc 'content tt)))
                      (cond ((string-equal name "header")
                             (pns-create-templates tt
                                                   (append c-header (read content))
                                                   c-content))
                            ((string-equal name "content")
                             (pns-create-templates tt
                                                   c-header
                                                   (concat c-content content)))))))
                children))))

    (defun pns-convert-to-string-filed (lst)
      (tracel lst)
      (mapcar (lambda (parameter)
                (if (listp parameter)
                    (cons (format "%s" (car parameter))
                          (if (> (length (cdr parameter)) 1)
                              (pns-convert-to-string-filed (cdr parameter))
                            (format "%s" (car (cdr parameter)))))
                  ;; for (name v1 v2 v3) cases. lst now is (v1 v2 v3)
                  (format "%s" parameter)))
              lst))

    ;; This works as main function

    (defun pns-create-templates-1 (snippet-file)
      "Given snippet org file, return the templates list"
      (setq pns-tmp-header nil)
      (setq pns-tmp-templates nil)
      (pns-create-templates
       (pns-convert-block-list-to-tree (pns-get-all-src-blocks snippet-file pns-snippet-entry-regexp))
       nil nil)

      (mapcar (lambda (tmpl)
                (let ((header (pns-assoc 'header tmpl))
                      (content (pns-assoc 'content tmpl)))
                  (list (cons 'header (pns-convert-to-string-filed header))
                        (cons 'content content))))
              pns-tmp-templates)
      )

    (defun pns-main-1 ()
      (interactive)
      ;; for open command:
      (setq pns-header-names '("command" "target" "for" "file"))
      
      ;; for close command:
      (setq pns-header-names '("command"))
      
      ;; for read command:
      (setq pns-header-names '("command" "file-handler" "to" "type"))
      
      (setq pns-templates (pns-create-templates-1 pns-snippet-file))
      (message "pns-templates updated.")
      )

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    ;; (message "Rst: %S"
    (pns-convert-block-list-to-tree (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp))
    ;; )


    ;; (message "Rst: %S"
    (pns-print-tree
     (pns-convert-block-list-to-tree '(
                                       ((level . 1) (name . "A"))
                                       ((level . 2) (name . "B1"))
                                       ((level . 2) (name . "B2"))
                                       ((level . 3) (name . "C1"))
                                       ))
     )
    (defun my-append-1 (a b)
      (concat a b))

    ;; (append nil (read "'((a b) (c d))"))

    (defun my-append (a b)
      (tracel a b)
      (append (and a (read (concat "" a))) (and b (read (concat "" b)))))

    (setq a (append nil (read "((command open) (target file)
        (for ((read <) (write >) (append >>) (readwrite +>)))
        (file))
    ")))


    (mapcar (lambda (block)
              (message "level: %s, name: %s, leafp: %s."
                       (pns-assoc 'level block)
                       (pns-assoc 'name  block)
                       (pns-assoc 'leafp  block))
              (cond ((string-equal (pns-assoc 'name block) "header")
                     (if (pns-assoc 'level block)
                         (push (append current-header (pns-assoc 'header block)) ))
                     ))
              )
            (pns-add-leafp-to-src-blocks (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp)))


    #+end_src
    
*** how to run
    1. run pns-create-templates and assign the result to pns-templates
       before asssing, should convert filed to string
       The input file is "perl-file-processing.org", saved in variable pns-snippet-file.
       
    3. manualll set pns-header-names
       Latter we should calculate the header dynamiccly.
       
       for open command:
       (setq pns-header-names '("command" "target" "for" "file"))
       
       for close command:
       (setq pns-header-names '("command"))
       
       for read command:
       (setq pns-header-names '("command" "file-handler" "to" "type"))
       
    4. run pns-main
       but first bind below variables, because we don't bind it in the env now.
       
       For open command, also bind the two variables.
       (setq for-value ">")
       (setq for-key "read")
** implementation
*** tangle
    #+name: sources
    #+begin_src elisp :noweb yes :tangle pns.el
    <<vars>>
    <<methods>>
    <<misc>>
    <<init>>
    #+end_src
** issues
*** DONE " myTemp" not killed may cause snippet file not found
    CLOSED: [2017-01-03 Tue 11:45]
    - State "DONE"       from ""           [2017-01-03 Tue 11:45]
    If snippet is relative path, then if this function exit without kill the buffer, then the buffer will keep exists.
    Fix by first kill the buffer.
    #+NAME: no-name
    #+begin_src elisp
(defun pns-get-all-src-blocks (snippet &optional entry)
  "Get all src blocks of the given snippet file name, return as a list. All src blocks should be in a entry, or there will be error. If the entry is provided, then only get that entry's src blocks. entry is regexp to match a headline "
  (let (tmp rst)
    ;; create temp buffer without undo record or font lock. (more efficient)
    ;; first space in temp buff name is necessary
    (set-buffer (get-buffer-create " myTemp"))
    (tracel snippet)
    (insert-file-contents snippet nil nil nil t)

 
    #+end_src
*** DONE let the user input value if a parameter's value is "nil"
    CLOSED: [2017-01-03 Tue 15:43]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 15:43] \\
      Create a special case for this situation.
      (if (and (stringp (car values)) (string-equal (car values) "nil"))
      
      At create expand-env,  contains function, and prompt for input.
    - State "STARTED"    from ""           [2017-01-03 Tue 14:45]
    Now the parameter is just selected.
*** DONE create a function to create expand-env for yas-expand-snippet
    CLOSED: [2017-01-03 Tue 16:00]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 16:00]
    - State "STARTED"    from ""           [2017-01-03 Tue 15:54]
    Currently the codes are in another function.
    
*** DONE build pns-header-names dynamically based on pns-templates
    CLOSED: [2017-01-03 Tue 17:26]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 17:26]
      Rewrite pns-prompt-for-header. the codes not good.
      The codes 
    - Note taken on [2017-01-03 Tue 17:20] \\
      Arealdy fixed the bug. And find a new bug in create templates from snippet file: if a parameter has multiple values, it will have only one value, which is the string of that list.
    - State "STARTED"    from ""           [2017-01-03 Tue 16:07] \\
      This function should be modified.
      (defun pns-prompt-for-header (header-names)
    Now it is specified in pns-main-1

*** DONE create templates bug: multiple parameter values will be one
    CLOSED: [2017-01-03 Tue 17:43]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 17:43] \\
      Codes is correct. It is the snippet error. So modify snippet to fix it.
      
      This function do the conversion. recursively.
      (defun pns-convert-to-string-filed (lst)
    - State "STARTED"    from ""           [2017-01-03 Tue 17:33]
   find a new bug in create templates from snippet file: if a parameter has multiple values, it will have only one value, which is the string of that list.

*** CANCELLED Symbol’s value as variable is void: for-value
    CLOSED: [2017-01-03 Tue 18:07]
    - State "CANCELLED"  from "STARTED"    [2017-01-03 Tue 18:07] \\
      the name represent the value, no need to write name-value. So I feel this function isn't that so useful.
    - Note taken on [2017-01-03 Tue 17:51] \\
      expand-env works like let*. so we can just add a function to create the variables.
      Below codes works
      
          #+NAME: no-name
          #+begin_src elisp
          (yas-expand-snippet "open my $fh, \"`for-value`\", ${1:file};" (point) (point) '((for (read "<++")) (for-value (if (consp for) (cdr for) for))))
          #+end_src
    - Note taken on [2017-01-03 Tue 17:46] \\
      for-key   should be (if (consp for) (car for) for)
      for-value should be (if (consp for) (cdr for) for)
      
      This works for all expand-evn variable.
    - State "STARTED"    from ""           [2017-01-03 Tue 17:45]
    Symbol’s value as variable is void: for-value', open or die "Open command for [yas] elisp error: Symbol’s value as variable is void: for-key failed";

*** STARTED write a snippet file for java file processsing,  by nio and io
    - State "STARTED"    from "TODO"       [2017-01-03 Tue 20:10]
    - State "TODO"       from ""           [2017-01-03 Tue 18:17]
    create a new snippet file under ./snippets/.

    The perl file processing snippet now works quite good. Maybe we can share headers between different language, then converting to indepenndent templates. This the key to uniform all language with same promption. But the drawbacks is maybe we need prompt for more data to make it uniform.
    Add many lanuage's file processing apis in to one snippet file, and see how it works, do there will be some problem.

    #+NAME: no-name
    #+begin_src elisp
(setq pns-snippet-file (expand-file-name "snippets/file-processing.org"))
    #+end_src

    #+RESULTS: no-name
    : /Users/astropeak/Dropbox/project/aspk-new-snippet/snippets/file-processing.org

    
*** multiple snippet files supports, integrated to helm-c-yasnippet
    Each file contains a list of templates. different file's templates are independent.

*** throw error when current idx has more than one parameter keys
    Or the user will no know what going wrong.

    THis function:
    (defun  pns-prompt-for-header () 
  "Prompt for each parameter. Assumption: in the filtered templates, only one parameter key exists at pos idx. Not checked if there are two, but will use the first one silently. Snippet file should ensule this."
 
*** if root entry don't have a header src block, then children will be nil
    Root cause is parents's second element is nil, so the children will be nil.
    Should fix by setting all element of parents to rst.
    And also throw an error when children is nil, or idx exceed the max element in parents.

    (defun pns-convert-block-list-to-tree (blocks)
  "Covert a block list to a tree based on level. use the children and parent property"
  (let* ((elem nil)
         (idx 0)
         ;; below line will not work, the rst will change every time. Acturally, it will be the same value the last time run
         ;; (rst '((children . (a)) (parent . nil)))
         ;; this works though
         (rst (list (list 'children idx) (list 'parent)))

         ;; parents save the current level parent block
         # (parents (list rst rst rst nil nil nil nil)) ;; this will work
         (parents (list rst nil nil nil nil nil nil))

*** DONE a bug: header ((buffer-types Byte Char Int)), pns-convert-to-string-filed  not works
    CLOSED: [2017-01-03 Tue 22:25]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 22:25]
    - State "STARTED"    from ""           [2017-01-03 Tue 22:23]

    Below is modified vesion. seems it works
    (defun pns-convert-to-string-filed (lst)
  (tracel lst)
  (mapcar (lambda (parameter)
            (if (listp parameter)
                (cons (format "%s" (car parameter))
                      (if (> (length (cdr parameter)) 1)
                          (pns-convert-to-string-filed (cdr parameter))
                        (format "%s" (car (cdr parameter)))))
              (format "%s" parameter)))
          lst))

*** should provide a way to define non selectable parameters.
    e.g. buffer-types parameter just servered as an global variable, not the headers.

    To fix, there are two ways: define other src names, such as 'global-definition' instead of 'header', the latter is used for prompt for input.
    two: still use header name, but...
    I prefer the first one.

*** DONE seems if parameter is (name value1 value2), the helm selection will hang
    CLOSED: [2017-01-03 Tue 21:49]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 21:49] \\
      pns-contains don't consider this situation.
    - State "STARTED"    from ""           [2017-01-03 Tue 21:34]
    (name (key1 value1) (key1 value2)) works.

*** STARTED can't reference another variables in header
    - Note taken on [2017-01-03 Tue 22:14] \\
      this variable should be expanded before pass to yas-expand-snippet.
      May be I should give up this now.
    - State "STARTED"    from ""           [2017-01-03 Tue 21:58]
    e.g.
    ((buffer-types Byte Int ...))
   ((command create-buffer) (type buffer-types))
   type refer to buffer-types

   But in pns-templates, type's reference value 'buffer-types' will be convert to string directly.
   ("type" . "buffer-types")

   Solution: should define a method to show how to do variable reference, now they will all be converted to string.
   I will use the commer syntax. if a name is preceeded by a commer, then we will not convert it to a string. So the definition will be changed to:
    ((buffer-types Byte Int ...))
   ((command create-buffer) (type ,buffer-types))

** run
   First run pns-main-1 to generate pns-templates from pns-snippet-file
   Then run pns-main to do the interactive selection and it will generates the code.
