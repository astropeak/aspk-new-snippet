* pns
** overal note
   - aspk-new-snippet can completely replace aspk-code-snippet.
   - write by literate programming.
     All source code contains in this org file
   - based on org-mode, yasnippet, helm
     snippet is saved in org-mode file, can can have a tree structure.

** doc
*** get snippet by parsing org mode file
    by this function:
    #+NAME: no-name
    #+begin_src elisp
(pns-update-template-list)
    #+end_src

    This function will update pns-template-set, which is a hash table, used to save template.
    
**** get src blocks in a org-mode file
***** example
      There are 3 blocks in the org file, but one is filterd out, so the result is 2 blocks.
      A proble can be seen: the block name is always empty.
      (press C-c C-c to run the src block)
      #+begin_src emacs-lisp 
      ;; (setq org-mode-file-name (aspk-org-tangle-next-test-data-block))
      (setq org-mode-file-name "test/data/1.org")
      ;; (format "%S" (pns-get-all-src-blocks org-mode-file-name nil "data"))
      (format "%S" (pns-get-all-src-blocks org-mode-file-name))
      #+end_src

      #+RESULTS:
      : (((beginning . 29) (end . 73) (name . "  ") (lang . "emacs-lisp") (tag . "") (content . "elisp") (level . 1) (heading . "headline 1")) ((beginning . 154) (end . 211) (name . "  ") (lang . "python") (tag . ":results output") (content . "python") (level . 1) (heading . "headline 2")))

      This is the input of test case:
      #+name: input
      #+begin_src org
      ,#+begin_src emacs-lisp
      elisp
      ,#+end_src

      ,#+begin_src emacs-lisp :not-a-snippet
      elisp2
      ,#+end_src

      ,* headline 2
      ,#+begin_src python :results output
      python
      ,#+end_src
      #+end_src


      This is the expected result of the test case:
      #+name: result
      #+begin_src emacs-lisp
      '(((beginning . 14) (end . 52) (name . "") (lang . "emacs-lisp") (tag . "") (content . "elisp") (level . 1) (heading . "headline 1"))
        ((beginning . 123) (end . 174) (name . "") (lang . "python") (tag . ":results output") (content . "python") (level . 1) (heading . "headline 2")))
      #+end_src

***** main function
      Function get all src block, (name, content, belonging-heading-level), in the same order they are defined.
     
     Give an org file, get all src blocks as a list.
    #+NAME: methods
    #+begin_src elisp
    (defun pns-get-all-src-blocks (snippet &optional entry name)
      (pns-src-block-filter
       (pns-get-all-src-blocks-coolie snippet entry name)))

    (defun pns-get-all-src-blocks-coolie (snippet &optional entry name)
      "Get all src blocks of the given snippet file name, return as a list. All src blocks should be in a entry, or there will be error. If the entry is provided, then only get that entry's src blocks. entry is regexp to match a headline. If name is given, only get blocks with NAME."
      (let (tmp rst)
        ;; create temp buffer without undo record or font lock. (more efficient)
        ;; first space in temp buff name is necessary
        (and (get-buffer " myTemp") (kill-buffer " myTemp"))
        (set-buffer (get-buffer-create " myTemp"))
        (insert-file-contents snippet nil nil nil t)

        ;; get only the entry's content
        (when entry
          (goto-char 1)
          (if (re-search-forward entry nil t)
              (let ((heading (match-string 0))
                    (entry (org-get-entry)))
                (erase-buffer)
                (insert heading)
                (insert "\n")
                (insert entry))
            (error "Entry %S not found, file: %s, src block name: %s." entry snippet name)))

        ;; (write-file "aaa")
        (goto-char 1)
        (while (setq tmp (pns-get-src-block-info name))
          (push tmp rst))
        (prog1 (reverse rst)
          (kill-buffer " myTemp"))))
    #+end_src
***** get a src block in current buffer
     #+name: methods
     #+begin_src emacs-lisp
     (defun pns-get-src-block-info (&optional name)
       "Get one src block after current positon in current buffer, return as a accoc list of block info. If no src blocks, return nil, and position will not be moved. If NAME is given, then only get a src block with that NAME. NAME is a regular expression that must contain a match pair \\(\\), to let the re searching get the result.
             The codes are copied form org-babel-find-named-block .
         "
       ;; Return value example: ((tag . ":not-a-snippet :noweb") (beginning . 179) (end . 228) (name . "  ") (lang . "elisp") (content . "  \"^\\\\\\\\*+[ \\t]+\"\n") (level . 1) (heading . "regexp value: org mode headline/title (** a title)"))
       (interactive)
       ;; (or name (setq name "\\(.*\\)"))
       (let* ((case-fold-search t)
              (regexp (if name (concat org-babel-src-name-regexp name "[ \t(]*[\r\n]\\(?:^#.*[\r\n]\\)*"
                                       (substring org-babel-src-block-regexp 1))
                        org-babel-src-block-regexp)))

         (when (re-search-forward regexp nil t)
           (append
            ;; position: beginning and end
            (list (cons 'beginning (match-beginning 0))
                  (cons 'end (match-end 0)))

            ;; src block name, lang, tag, content
            (mapcar (lambda (elem)
                      (let ((idx (car elem)) (property-name (cdr elem)))
                        (cons property-name
                              (if (equal property-name 'content)
                                  (pns-post-process-src-block-content
                                   (substring-no-properties (or (match-string idx) "")))
                                (substring-no-properties (or (match-string idx) ""))))))
                    (if name
                        '((1 . name) (3 . lang) (5 . tag) (6 . content))
                      '((1 . name) (2 . lang) (4 . tag) (5 . content))))

            ;; belonging heading and level
            (save-excursion
              (let ((p (point)))
                (org-back-to-heading)
                (move-beginning-of-line 1)
                (if (re-search-forward "^\\(\\*+\\)\s+\\(.*\\)" p t)
                    (list (cons 'level (length (match-string 1)))
                          (cons 'heading (substring-no-properties (match-string 2)))))))))))

     ;; there is a bug in regexp-quote: '\\|' will be quoted to '\\\\|'

     (defun pns-post-process-src-block-content (content)
       (pns-remove-leading-spaces 
        (pns-remove-src-block-last-new-line-char 
         (pns-unquote-src-block-content content)))
       )

     (defun pns-unquote-src-block-content (content)
       "Remove all leading ',' in each line of content"
       (replace-regexp-in-string "^\\(\s*\\)," "" content)) ;;remove all leading line helps indent.

     (defun pns-remove-src-block-last-new-line-char (content)
       "Remove the last new line char in content. Because when using it as a snippet, it always has a new line char at the end which is not needed"
       (replace-regexp-in-string "\n$" "" content))

     (defun pns-remove-leading-spaces (content)
       "Remove unneeded leading spaces in each line of CONTENT"
       (let ((unneeded-spaces 
              ;; (when (not (equal (string-match "^\s*" content) 0))
              ;;   (match-string 0))
              (with-temp-buffer (insert content) (goto-char 1)
                                (when (re-search-forward "^\s+" nil t)
                                  (match-string 0)))
              ))
         (if unneeded-spaces
             (replace-regexp-in-string (format "^%s" unneeded-spaces) "" content)
           content)))

     #+end_src

    
    #+NAME: vars-
    #+begin_src elisp
    (setq pns-src-block-name-regexp "\\(header\\|content\\)")
    #+end_src

    #+name: test-
    #+begin_src elisp
    (defun pns-tmp ()
      (interactive)
      (save-excursion
        (message "%s" (pns-get-src-block-info))))
    #+end_src

    #+RESULTS: test-
    : pns-tmp

***** filter out some src blocks
      Remove blocks whose tag contains ':not-a-snippet'
      #+name: methods
      #+begin_src emacs-lisp
      (defun pns-src-block-filter (blocks)
        "Filter src blocks.  Remove the blocks whose tag contains ':not-a-snippet. This is a way to indicate a src block is not used as a snippet"
        (-filter (lambda (x) (not (s-contains? ":not-a-snippet" (pns-assoc 'tag x))))
                 blocks))
      #+end_src

 
*** expand a snippet 
    pns-expand-template-by-name 
*** var-table, hungry-vars in a template
    hungry-vars: a list of (VAR VALUE), which is used to passed to yas-expand-snippet as the EXPAND-ENV parameter.
    var-table: a list of (VAR POSSIBLE-VALUE), which is used to define possiable values for a var. That (DEMO VERSION!) information comes from the org mode snippet blocks.

    The `emacs-lisp-code` syntax in a yas (DEMO VERSION!) snippet let user embed a emacs lisp code inside the snippet.
    The emacs-lisp code will be evaluated .

    PNS use this feature to embed a variable in snippets. This is achieved by:
    1. put a (var value) in expand-env parameter of yas-expand-snippet.
    2. use `var` in the snippet text to refer to that var.
    
    Because variables in the expand-env parameter will be defined like a let variable, so it will be a locale variable when the snippet is expanded. so the syntax `var`is acturally refers to a variable. A variable in list evaluates to its value.

    This is an example, it will expand to "name: Tom".
    #+NAME: no-name
    #+begin_src elisp
    (yas-expand-snippet "name: `name`" nil nil '((name "Tom")))
    #+end_src

    
** inbox
*** 170101, thinking and ideas
    # -*- mode: snippet -*-
    #name : create a buffer(should not expand this)
    #expand-env : ((pcs-yas-method (helm-other-buffer '((name . "Method?") (candidates . ("allocate" "direct" "wrap")) (action . (lambda (c) c))) "Which mode "))) 
    #contributor : Astropeak
    #description : 
    #key:aaa
    this doen't work
    `(progn
    (message "mode: %S, hook: %S" yas-minor-mode post-command-hook)
    (yas-expand-snippet
    (cond ((string-equal pcs-yas-method "wrap")
    "ByteBuffer buffer = ByteBuffer.wrap(${1:array});"))))`
    
    # New method:
    many blocks, each block has a header:
    The header format: 'var-name:value-regexp, xx:yy, ...'
    The block expand rule: the only one simple rule: if the var matches the value regexp, then the block will be expanded.
    
    All expanded blocks will be merged to a single snippet, and be passed to yasnippet to do the expanding. So this kind of snippet will be compiled to a yasnippet snippet.
    # --
    
    #++ method:wrap
    ${1:type}Buffer ${2:buffer} = $1Buffer.wrap(${3:array});
    
    #++ method:allocate
    ${1:type}Buffer ${2:buffer} = $1Buffer.allocate(${3:size});
    
    #++ method:direct
    ${1:type}Buffer ${2:buffer} = $1Buffer.directAllocate(${3:size});
    
    
    the procesor will look the header for all possiable values and prompt for the user. This idea is great!!!
    more than one commands can be choosed in a pass.
    
    则学习的过程就是写模板的过程。使用模板编程时，我就全部使用的是高级概念，而不需要关注细节。比如process buffer, 这里的子项包括创建、打开、读取、写入、关闭、刷出、与数组转换、与其它类型转换 等常用操作。而这些子项都会通过提示的方式显现出来，再也不需要记那么多东西。
    
    一个var的值也可以是一个list，则所有的可选值可在一个block中指定。同时在block中需要能够获得这个var的值，也能够做一些transformation,以此将该值转换在目标中。list的元素也可是一个cons，则值也显示将分离。
    采用这种方法，多个block可被合并为一个，简化编写工作。
    缺点是依赖于这个参数的参数将不太好做了。=》可能通过定义依赖来定义一个元素的值。
    
    块的顺序会有关系，因为可以多个块会被选中。顺序通过写时保证。
    
    ## Example: for processing file
    ##command: open, read, write, close, flush
    ##type: file, pipe, socket
    ##for: read, write, append, readwrite. only applicable for command open
    
    #++ command:open, type: file, for:read
    open a file for read
    
    #++ command:open, type: pipe, for:read
    open a pipe for read
    
    
    
    #++ command:open
    close the file
*** a new snippet sample
    #+BEGIN_SRC text
    ## Example: for processing file
    ##command: open, read, write, close, flush
    ##type: file, pipe, socket
    ##for: read, write, append, readwrite. only applicable for command open

    ,#+ ((command open) (type file) (for ((read <) (write >) (append >>) (readwrite +>))))
    open my $fh, `for`, ${1:file} or dir "Open file failed";

    ,#+ command:open, type: pipe, for:read
    open my $fh, "-|", ${1:command} or dir "Open command failed";


    #+END_SRC
*** test yas-expand-snippet
    `for` will be replaced to <
    #+NAME: no-name
    #+begin_src elisp
    (yas-expand-snippet "open my $fh, \"`for-value`\", ${1:file};" (point) (point) '((for (read "<++")) (for-value (if (consp for) (cdr for) for))))

    #+end_src
*** hatch codes: given templates list, prompt for input and expand a snippet
    a template, get form the new snippet file
    #+NAME: vars 
    #+begin_src elisp
    (setq pns-templates
          '(
            ((header . (("command" . "open") ("type" . "file") ("for" . (("read" . "<") ("write" . ">") ("append" . ">>") ("readwrite" . "+>")))))
             (content . "open my $fh, '`for`', ${1:file} or dir 'Open file failed';"))

            ((header . (("command" . "open") ("type" . "pipe") ("for" . (("read" . "|-") ("write" . "-|")))))
             (content . "open my $fh, '`for`', ${1:command} or dir 'Open command failed';"))
            ))
    #+end_src
    
    
    process step:
    1. for each parameter, merge to one list for selection
    2. based on the selected result, rebuild the list, the list that not match the result should be removed.
    3. repeat step 1, process next parameter.
       
       传入一个header列表，返回所有与这个列表匹配的contents
       select-content
       #+NAME: methods
    #+begin_src elisp
    (defun pns-contains (list1 list2)
      "Both list1 and list2 are assoc list. Return true if list1 contains all elements in list2. Definition:contains: elements in list2 exists in list1. The equal functon is string-equal or ... for subelement.
    e.g. list1 is header of a template, list2 is the selected data.
    "
      ;; TODO: should I consider order? 
      (let ((rst t)
            (e1))
        (mapc (lambda (e2)
                (setq e1 (assoc (car e2) list1))
                (unless (and e1 (cond ((stringp (cdr e1))
                                       (or (string-equal (cdr e1) "nil")
                                           (string-equal (cdr e2) (cdr e1))))
                                      ;; what's the logic here? =>(cdr e1) is a assoc list, while (cdr e2) always a string or something else. If (cdr e2) exists in (cdr e1)'s key set, then it means e1 contains e2.
                                      ;; BUG here. (cdr e1) also may be a list of string.
                                      ((and (listp (cdr e1)) (listp (car (cdr e1)))) (assoc (cdr e2) (cdr e1)))
                                      ((and (listp (cdr e1)) (stringp (car (cdr e1))))
                                       (member (cdr e2) (cdr e1)))
                                      (t (error "parameter format wrong: %S" e1))))
                  (setq rst nil)))
              list2)
        rst))



    (defun pns-filter-templates (header)
      "Get all templates whose header contains parameter"
      (delete nil
              (mapcar (lambda (tmpl)
                        (when (pns-contains (cdr (assoc 'header tmpl)) header)
                          tmpl))
                      pns-templates) ))

    (defun pns-get-contents (header)
      "Get all matched template's content. Match means its header contains the parameter header"
      (mapcar (lambda (tmpl) (cdr (assoc 'content tmpl)))
              (pns-filter-templates header)))


    #+end_src
    
    #+RESULTS: select-content
    | open my $fh, '`for`', ${1:file} or dir 'Open file failed'; |
    
    #+NAME: test-get-contents
    #+begin_src elisp
        (pns-get-contents '())

        (pns-get-contents '(("command" . "open")  ("for" . "read")))

        (pns-get-contents '(("type" . "file") ))

        (pns-get-contents '(("command" . "open") ("type" . "file") ("for" . "read")))

    #+end_src
    
    get header element value list
    #+NAME: methods
    #+begin_src elisp
    (defun pns-get-header-element-values (header-element-name &optional header-filter)
      "Get all values of a header element given its name, as a list. A name e.g. type, for, command. `header-filter' is a filter to filter the pns-templates before get."
      (unless header-filter (setq header-filter '()))
      (delete-dups
       (let ((rst nil))
         (mapc (lambda (tmpl)
                 (let* ((header (cdr (assoc 'header tmpl)))
                        (elem (assoc header-element-name header))
                        (value (and elem (cdr elem))))
                   (and value (cond ((stringp value) (setq rst (append rst (list value))))
                                    ((listp value)
                                     (setq rst (append
                                                rst (mapcar (lambda (ee)
                                                              (if (listp ee) (car ee) ee))
                                                            value))))))))
               (pns-filter-templates header-filter))
         rst)))

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    (pns-get-header-element-values "for" '(("type" . "file")))
    #+end_src
    
    
    #+NAME: vars
    #+begin_src elisp
    ;; a list of header element names that we will get value
    (setq pns-header-names '("command" "type" "for"))
    #+end_src
    
    The basic functions ready, now built the app.
    #+NAME: methods
    #+begin_src elisp
    (defun  pns-prompt-for-header (&optional filter-header) 
      "Prompt for each parameter. Assumption: in the filtered templates, only one parameter key exists at pos idx. Not checked if there are two, but will use the first one silently. Snippet file should ensule this."
      (let ((templates t) (runp t)
            first-header key values tmp input
            (idx 0) rst)
        (while runp
          (tracel filter-header)
          (setq templates (pns-filter-templates filter-header))
          (unless templates (error "template nil. filter-header: %S" filter-header))
          (when  templates
            (setq first-header (pns-assoc 'header (car templates)))
            (setq key (car (nth idx first-header)))
            (unless key (setq runp nil))
            (when key
              (incf idx)
              (tracel first-header key idx)
              (if (assoc key filter-header)
                  (push (cons key (pns-assoc key filter-header)) rst)
                (setq values (pns-get-header-element-values key filter-header))
                (if (= (length values) 1)
                    (progn
                      (setq tmp (car values))
                      (setq input (car values))
                      (when (string-equal (car values) "nil")
                        ;; prompt for this key by read-string if (car vallues) is "nil"
                        ;; read-string will change point
                        (save-excursion
                          (setq input (read-string (format "%s: " key))))))
                  ;;>1. prompt for this key by helm
                  (setq input (helm-other-buffer `((name . ,key) (candidates . ,values)
                                                   (action . (lambda (c) c)))
                                                 "Select"))
                  (setq tmp input))
                (push (cons key tmp) filter-header)
                ;; this is the result
                (push (cons key input) rst))
              )
            ))
        (reverse rst)))

    (defun pns-prompt-for-header-old (header-names)
      "Based on the templates, prompt for each parameters"
      (let ((headers))
        (mapcar (lambda (key)
                  (let ((values (pns-get-header-element-values key headers))
                        tmp)
                    (tracel values)
                    (if (= (length values) 1)
                        (if (and (stringp (car values)) (string-equal (car values) "nil"))
                            (setq tmp (read-string (format "%s: " key)))
                          (setq tmp (car values)))
                      (setq tmp (helm-other-buffer `((name . ,key) (candidates . ,values)
                                                     (action . (lambda (c) c)))
                                                   "Select")))
                    (tracel key tmp)
                    (push (cons key tmp) headers)
                    (cons key tmp)))
                header-names)))

    (defun pns-create-expand-env (header tmpl)
      "Convert header to a expand-env that can be passed to yas-expand-snippet. header is a list, element is (key . value), both key and value are strings. The main job is handle this kind of parameter: (key (k1 v1) (k2 v2)), and changet the key to a symbol from string, change to a list from a cons"
      (let (tmp tmp1)
        ;; elem is a parameter
        (mapcar (lambda (elem)
                  ;; tmp is all possible values for the element key. TODO: where is definiton of tmpl?
                  (setq tmp (cdr (assoc (car elem) (cdr (assoc 'header tmpl)))))
                  ;; tmp1 is the target value
                  (setq tmp1 (cdr elem))
                  (cond ((listp tmp)
                         (mapc (lambda (vv)
                                 (if (consp vv)
                                     (when (string-equal (cdr elem) (car vv))
                                       (setq tmp1 (cdr vv)))))
                               tmp)))

                  (tracel elem tmp tmp1)
                  ;; elem: ("command" . "open"), tmp: "open", tmp1: "open"
                  ;; elem: ("type" . "file"), tmp: "file", tmp1: "file"
                  ;; elem: ("for" . "read"), tmp: (("read" . "<") ("write" . ">") ("append" . ">>") ("readwrite" . "+>")), tmp1: "+>"
                  (list (intern (car elem)) tmp1))
                header)))

    (defun pns-do-expand (&optional filter-header)
      "given header element list, expand a snippet."
      (let* ((header (pns-prompt-for-header filter-header))
             (templates (pns-filter-templates header)))
        (tracel header)
        (mapc (lambda (tmpl)
                (yas-expand-snippet (cdr (assoc 'content tmpl)) (point) (point)
                                    (pns-create-expand-env header tmpl)))
              templates)))

    (defun pns-main ()
      (interactive)
      (pns-do-expand))

    (defun pns-main-shortcut ()
      (interactive)
      (pns-do-expand '(("command" . "create-channel") ("for" . "read") ("file-name" . "\"aaa.b\""))))

    #+end_src
    
    #+RESULTS: methods
=pns-get-all-src-blocks-coolie
==pns-src-block-filter
==pns-tool-convert-all
=    ==============    ==    ==    ===================pns-do-xxx
    =    
    
    #+NAME: test-
    #+begin_src elisp
    (pns-prompt-for-header)
    (pns-get-contents (pns-prompt-for-header))
    (pns-do-expand pns-header-names)
    #+end_src
    
*** ideas
    header的各个元素中，每个元素之间是有关系的。目前采用的方式是随意组合。如第一个元素有2个值，第二元素有3个值，则所有可能取值有2x3=6种。
    但还有种情况，比如第一个元素取第1个值时，第二个元素只能取前2个值；第一个元素取第2个值时， 第二个元素只能取后两个值，则所有取值有2x2处。
    如何表示这种关系呢？使用树完全是可行的，但写起来比较复杂，也不好看。 直接指定一个元素的子节点如何？通过下标。比如(children . (0 1))。 当没有指定children时，则表示children可以取所有值。 这种其实和树的效果是一样的。
*** the nio snippet sample
    Mon Jan  2 09:44:32 2017
    写这个文件花了大约一个多小时，在写的过程中，我观察结构，思考各种可能问题，着重解决分块与组合的问题。 最终想到了一种非常巧妙的方法：使用类似org mode文件的树结构来模板。
    分块有利于模板文件的编写，修改、新增都会比较方便。组合则给进一步的封闭带来便利。这两个方面均可通过org mode文件解决。
    
    一个模板块可以wrap其它模板块。这种主义也要支持。
    
    心得： 必需得通过用例，才能有想法，完全空想，基本上什么也想不出。
    #+BEGIN_SRC text
    ## the four command are independent. To expand all of four, just expand all four step by step


    ##TODO: define a major mode: display the source codes in java format, while all lines begin with a '#' in another look. fold function.


    ##通过第一个参数选择要分别展开哪些宏。第一个参数与后面的参数有什么不同？ 不同点在于在写这个模板时，就是根据第一个参数进行区分的。？这样有没有什么限制？ 应该也可以写sub command，但在不同层级。 比如 #+ 表示第一层， #++表示第二层，#+++表示第三层。 这是文本文件表达树的最佳方式，就像是org mode一样。 通过树的结构，属性继承也会方便很多。同时，感觉没必要保持严格的顺序了，完全可以通过参数指定顺序。 这个想法也是非常牛逼啊！！树的结构，对于修改及新增都有很大的便利性。
    就使用org文件吧， 这样可以继承大量代码。


    ## #++ define global variables
    ,#++ ((buffer-types '(byte int short char long float double)))

    ## nil means the value should be provided by users.
    ,#+ ((command . create-channel) (type . (in out)) (file-name . nil))
    {
        FileOutputStream fout = null;
        try {
            fout = new FileOutputStream(${1:file});
            FileChannel fc = fout.getChannel();

    ,#+ ((command create-buffer) (type . ,buffer-types)(method . (allocate direct-allocate) (size . nil)))
            ByteBuffer buffer = ByteBuffer.allocate(${2:1024});

    ,#+ ((command create-buffer) (type . ,buffer-types)(method . wrap) (array-name . nil)))
            ByteBuffer buffer = ByteBuffer.wrap(${2:1024});

    ,#+ ((command fill-buffer) (buffer-type . ,buffer-types) (content-type . (byte[] String)))
            buffer.clear();
            // fill the buffer with contents to write to a file
            final byte message[] = { 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 };
            for (int i=0; i<message.length; ++i) {
               buffer.put( message[i] );
            }

    ## how to express: this header is dependent on create-channel, type out? I think don't try to do this, this should be ensured by the user
    ,#+ ((comand write-buffer-to-channel))
            buffer.flip();
            fc.write(buffer);
           

    ,#+ ((comand read-buffer-from-channel))
            buffer.clear();
            while (fc.read(buffer) != -1) {

    ,#+ ((command extract-buffer) (buffer-type . ,buffer-types) (content-type . (byte byte[] String)))
                //now file contents saved in buffer, add process codes here
                buffer.flip();
                 int i=0;
                 while (buffer.remaining()>0) {
                     byte b = buffer.get();
                     System.out.print((char)b);
                     i++;
                 }
                
    ,#+ ((comand read-buffer-from-channel))
                buffer.clear();
            }


    ## here type should be the same as the above ones. All vars should be shared, if only they match. A child will inheritates property from its parent. if header 1 contains header 2, then header 1 is the parent, header 2 is the child.
    ## So in below header, it will inheritates 'type' and 'file-name' property from the first one.
    ,#+ ((command . create-channel))
        } catch (FileNotFoundException ex) {
            System.out.println(ex);
        } catch (IOException ex) {
            System.out.println(ex);
        } finally {
            try {
                if (fout != null) {fout.close();}
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }
    #+END_SRC
    
    用org文件重写，效果相当好。
    #+BEGIN_SRC org
    ,* doc
    ## the four command are independent. To expand all of four, just expand all four step by step


    ##TODO: define a major mode: display the source codes in java format, while all lines begin with a '#' in another look. fold function.


    ##通过第一个参数选择要分别展开哪些宏。第一个参数与后面的参数有什么不同？ 不同点在于在写这个模板时，就是根据第一个参数进行区分的。？这样有没有什么限制？ 应该也可以写sub command，但在不同层级。 比如 #+ 表示第一层， #++表示第二层，#+++表示第三层。 这是文本文件表达树的最佳方式，就像是org mode一样。 通过树的结构，属性继承也会方便很多。同时，感觉没必要保持严格的顺序了，完全可以通过参数指定顺序。 这个想法也是非常牛逼啊！！树的结构，对于修改及新增都有很大的便利性。
    就使用org文件吧， 这样可以继承大量代码。

    ,* ((global-variables . (buffer-types '(byte int short char long float double))))
      ## *+ define global variables

    ,* snippet: process files with buffer and channel, nio package
    ,** ((command . create-channel) (type . (in out)) (file-name . nil))
      ## nil means the value should be provided by users.
    ,*** ((command2 . init)
    {
        FileOutputStream fout = null;
        try {
            fout = new FileOutputStream(${1:file});
            FileChannel fc = fout.getChannel();

    ,*** ((command2 . cleanup))
        } catch (FileNotFoundException ex) {
            System.out.println(ex);
        } catch (IOException ex) {
            System.out.println(ex);
        } finally {
            try {
                if (fout != null) {fout.close();}
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }

    ,** ((command create-buffer) (type . ,buffer-types))
    ,*** ((method . (allocate direct-allocate) (size . nil))
            ByteBuffer buffer = ByteBuffer.allocate(${2:1024});

    ,*** ((method . wrap) (array-name . nil))
            ByteBuffer buffer = ByteBuffer.wrap(${2:1024});

    ,** ((command fill-buffer) (buffer-type . ,buffer-types) (content-type . (byte[] String)))
            buffer.clear();
            // fill the buffer with contents to write to a file
            final byte message[] = { 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 };
            for (int i=0; i<message.length; ++i) {
               buffer.put( message[i] );
            }

    ## how to express: this header is dependent on create-channel, type out? I think don't try to do this, this should be ensured by the user
    ,** ((command extract-buffer) (buffer-type . ,buffer-types) (content-type . (byte byte[] String))) (ref:crec code reading: TMA, ret voltage)
                //now file contents saved in buffer, add process codes here
                buffer.flip();
                 int i=0;
                 while (buffer.remaining()>0) {                           (ref:aaa) (ref:aaa bbb)
                     byte b = buffer.get();
                     System.out.print((char)b);
                     i++;
                 }
                

    ## here type should be the same as the above ones. All vars should be shared, if only they match. A child will inheritates property from its parent. if header 1 contains header 2, then header 1 is the parent, header 2 is the child.
    ## So in below header, it will inheritates 'type' and 'file-name' property from the first one.
    ,** ((command write-to-channel-from-buffer))
            buffer.flip();
            fc.write(buffer);
           
    ,** ((command read-from-channel-to-buffer))
    ,*** ((command2 part1))
            buffer.clear();
            while (fc.read(buffer) != -1) {
            // process buffer content here

    ,*** ((command2 part2))
                buffer.clear();
            }

    #+END_SRC
*** the perl processing file snippet in org mode format
    In this entry, the processing steps are described.
    
    #+BEGIN_SRC org 
    ,* ideas & docs
      - if a parameter has no value, then its value should be prompt for
        such as the '(file)' parameter.
      - maybe add a doc string to a parameter is a good idea. 
        And the doc string is optional. If it not exists, then the parameter key will be used. Angin a good idea.
        A parameter is e.g. '(command open)', 'command' is the parameter's key, 'open' is the parameter's value.
      - ((k1 v1) (k2 (v21 v22))) is the same as the two: ((k1 v1) (k2 v21)) and ((k1 v1) (k2 v22))
        We can always flatten the formmer to the latter to ease our implementation of parse the snippet. and we can make an header has uniform format by always transform it in this format: ((k1 v1 doc1) (k2 v2 doc2) ...), and k1 is always a symbol, v1 is always a cons of (key . value), doc1 is always a string of documentation of this parameter. This idea is great!! It greatly descreases the complexity of codes, for we only have one case to handle. A header is a list of parameters.
        
        When writting snippet, the latter form is better. It helps removing duplicates. But the former form also works. I love this flexibility!
      - put the header in a source block named header, put the expanded codes in a source block named content
        Currently the the header is put in the headline, then it's hard to write long headers.
      - Put the global parameters in the source block name global-definition
        And all the child entry and this entry can refer to that definition
        So just put parameters to the root entry, all the snippet can access to those.
        
        Seems the 'global-definition' and 'header' block have very small differences. The element(which is a parameter) in a 'global-definition' only has one possible value, while a 'header' can has may values. So we can use 'header' as 'global-definition'. 
        
        What we really need is global function definition. Those functions will be created and can be used in the everywhere. 
        Currently we can only support lambda functions to ease the implementation.
      - the processing steps of this file to transform it to a template list
        Note: a template is a list of ((header . H) (content . C))
        1. find the level 1 entry started with 'snippet:'
           Should have only one such entry. root-entry
        2. init current-templates to nil, current-header, current-content to nil,
           
        3. set current-entry to root-entry
           
        4. process the content of current-entry
           Note: content of an entry is the text betwwen the entry's headline and its first child entry's headline, exclusive.
           - for block named 'header', append all parameters of this header to current-header
             Note: I find no need to seperate parameter and functions, because they all server as a environment variable. And our algorithm is that we only prompt for selection or input only when a parameter has mulitple values or has no value. If it has only one value, then nothing will be done, it will server as an environment value only.
           - for block named 'content', append the content to current-content
             without adding any newline characters. So you should add new line in the block if wanted.
           - if this entry is a leaf, 
             then add ((header . current-header) (content . content)) to current-templates.
             then restore current-header and current-content to the original value.
             
           - else for all direct child entrys:
             loop with current-entry in all direct child entrys:
             repeat step 4.
             
        5. now current-templates contains all template of this snippet tree.
           
      - helm source candidate
        the level one snippet entry's headline and
        the direct child's headlines of level one shortcut entry
        will be added as helm source candidate
        
        For both candidates, the level one snippet entry will first be processed to a templates list.
        Note: maybe this can be processed at init stage and saved for latter use, and update when needed(such as the file has a newer version).
        Then for the first type of candidate, the filter will be set to '()
        for the second type of candidate, the filter will be set to source block 'filter' of that entry.
        Note: a filter is a list of parameters, and is used to give initial value to a parameter. Then that parameter will not be prompt for selction or value.
        
        
    ,* snippet: processing files, open, read, write, close
      ,#+name: header
      ,#+begin_src elisp
      ((snippet-name xxxxx))
      ,#+end_src
      
    ,** ((command open) (target file) (for ((read '<') (write '>') (append '>>') (readwrite '+>'))) (file))
       ,#+name: header
       ,#+begin_src elisp
       ((command open) (target file)
        (for (read <) (write >) (append >>) (readwrite +>))
        (file))
       ,#+end_src
       
       ,#+name: content
       ,#+begin_src perl :results output
       open my $fh, '`for`', `file` or die "Open file failed";
       ,#+end_src
       
       Notes on variable binding:
       For element type string, name, name-value, name-key all bind to the same string;
       For element type cons, name is binded to the cons, name-key will be binded to (car name), name-value will be binded to (cdr name).
       e.g.:
       if `for` is '(read '<')', `for-value` will be 'read', `for-key` will be '<'.
       if `target` is 'file', then `target-key`, `target-value` are all 'file'.
       
    ,** ((command open) (target pipe) (for ((read '|-') (write '-|'))) (command))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command open) (target pipe) (for (read |-) (write -|)) (shell-command))
       ,#+end_src
       
       ,#+name: content
       ,#+begin_src perl :results output
       open my $fh, '`for`', `shell-command` or die "Open command failed";
       ,#+end_src
       
    ,** ((command close))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command close))
       ,#+end_src
       
       
       ,#+name: content
       ,#+begin_src perl :results output
       close $fh;
       ,#+end_src
       
    ,** ((command read)  (file-handler) (to))
       ,#+name: header
       ,#+begin_src perl :results output
       ((command read)  (file-handler) (to))
       ,#+end_src
       
    ,*** ((type line))
        ,#+name: header
        ,#+begin_src perl :results output
       ((type line))
        ,#+end_src
        
        
        read a line from a file handler
        ,#+name: content
        ,#+begin_src perl :results output
       `to` = <`file-handler`>;
        ,#+end_src
    ,*** ((type whole-content-as-string))
        ,#+name: header
        ,#+begin_src perl :results output
       ((type whole-content-as-string))
        ,#+end_src
        
        
        read the file's whole content as a string
        ,#+name: content
        ,#+begin_src perl :results output
        local $/;
        `to` = <`file-handler`>;
        ,#+end_src
        
        
    ,* shortcut
      shortcut is a way to predefine some parameters so that these parameters will not be prompted to user for value.
      
    ,** open a file for read, and then close
       This shortcut contains two header, the first one will define three element. The whole:
       ,#+NAME: filter
       ,#+begin_src elisp
       (((command open) (target file) (for read))
        ((command close)))
       ,#+end_src
       Element is a header, each element will be processed in turn.
    #+end_src
       
       
    #+END_SRC
*** hatch codes: parse org mode file to templates list
    INFO. All org mode related codes
    #+NAME: no-name
    #+begin_src elisp

(org-entry-delete)
(org-entry-beginning-position)
(org-entry-end-position)
(org-entry-get)
(org-entry-get-with-inheritance)

(org-entry-properties)
(org-entry-is-todo-p)

(defun org-in-src-block-p (&optional inside)

(org-babel-src-block-names pns-snippet-file)

(defun org-goto-first-child ()
  "Goto the first child, even if it is invisible.
Return t when a child was found.  Otherwise don't move point and
return nil."

(defun org-back-to-heading (&optional invisible-ok)
  "Call `outline-back-to-heading', but provide a better error message."

(defun org-get-next-sibling ()
  "Move to next heading of the same level, and return point.
If there is no such heading, return nil.
This is like outline-next-sibling, but invisible headings are ok."


(defun outline-next-visible-heading (arg)

(defun outline-next-heading ()
(outline-level)
(org-entry-put)
(org-find-entry-with-id)

;; get the entry text, after heading, entire subtree
(org-get-entry)

(defun org-babel-next-src-block (&optional arg)
  "Jump to the next source block.
With optional prefix argument ARG, jump forward ARG many source blocks."
  (interactive "p")
  (org-next-block arg nil org-babel-src-block-regexp))


    #+end_src
    
    #+NAME: init
    #+begin_src elisp
(require 'aspk-debug)
    #+end_src
    
    #+NAME: vars
    #+begin_src elisp
    (defvar pns-snippet-file nil "snippet file name")
    (setq pns-snippet-entry-regexp  "^\*+\s+snippet.*")
    ;; (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp)
    #+end_src
    
    #+NAME: init
    #+begin_src elisp
    ;; (setq pns-snippet-file "perl-file-processing.org")
    (setq pns-snippet-file (expand-file-name "snippets/file-processing.org"))
    #+end_src
    
    
   
    convert the source blocks to templates list:
    Given src blocks, get the templates.
    #+NAME: methods
    #+begin_src elisp
    ;; add a filed: leafp
    (defun pns-assoc (key list)
      (cdr (assoc key list)))

    (defun pns-add-leafp-to-src-blocks (blocks)
      (let (elem rst)
        (while blocks
          (setq elem (car blocks))
          (setq blocks (cdr blocks))
          (if blocks
              (if (>= (pns-assoc 'level elem) (pns-assoc 'level (car blocks)))
                  (push (append (list (cons 'leafp t)) elem) rst)
                (push (append (list (cons 'leafp nil)) elem) rst))
            (push (append (list (cons 'leafp t)) elem) rst)))
        (reverse rst)))

    ;; a bug in emacs lisp: seems a list with the same symbol elemnt will has the same address.
    ;; (eq (list 'a 'b) (list 'a 'b))
    ;; After I change this line :
    ;; (setq elem (append elem `((children . (a)) ,(cons 'parent (list parent)))))
    ;; TO:
    ;; (setq elem (append elem (list (list 'children (format "%s-%s" (incf idx) level))
    ;; (list 'parent parent))))
    ;; Then the program works.

    ;; This is just waist of time!! emacs lisp's desctructive operateions are full of bug!!!! I have waste about 3 hours on this!! Fuck!!!!

    ;; Found another bug:
    ;; first time run pns-convert-block-list-to-tree, it gives good answer
    ;; then it gives double the good anwser, then triple, ...
    ;; DOn't know why
    ;; FOund the root cause:
    ;; the rst value will be not the same each time the program enter. Fuck!!
    ;; (let ((elem nil)
    ;; (rst '((children . (a)) (parent . nil)))


    (defun pns-print-tree (tree)
      ;; (message "Tree: %s" tree)
      (message "level: %s, name: %s"
               (pns-assoc 'level tree)
               (pns-assoc 'name tree))
      (mapc (lambda (tt)
              (if (listp tt)
                  (pns-print-tree tt))
              )
            (pns-assoc 'children tree)))


    ;; Now the function works!!!
    (defun pns-create-templates (block-tree c-header c-content)
      "Assue content block is behind of header block or it will be error."
      (tracel c-header)
      (let ((name (pns-assoc 'name block-tree))
            (children (pns-assoc 'children block-tree)))
        ;; (message "lenth children=%s" (length children))
        (if (= (length children) 1)
            ;;this is a leaf
            (cond ((string-equal name "header")
                   (setq pns-tmp-header c-header))
                  ((string-equal name "content")
                   (add-to-list 'pns-tmp-templates
                                (list (cons 'header pns-tmp-header) (cons 'content c-content))
                                t)))
          ;; this is a parent
          (mapc (lambda (tt)
                  (when (listp tt)
                    (let ((name (pns-assoc 'name tt))
                          (content (pns-assoc 'content tt)))
                      (cond ((string-equal name "header")
                             (pns-create-templates tt
                                                   (append c-header (read content))
                                                   c-content))
                            ((string-equal name "content")
                             (pns-create-templates tt
                                                   c-header
                                                   (concat c-content content)))))))
                children))))

    (defun pns-convert-to-string-filed (lst)
      (tracel lst)
      (mapcar (lambda (parameter)
                (if (listp parameter)
                    (cons (format "%s" (car parameter))
                          (if (> (length (cdr parameter)) 1)
                              (pns-convert-to-string-filed (cdr parameter))
                            (format "%s" (car (cdr parameter)))))
                  ;; for (name v1 v2 v3) cases. lst now is (v1 v2 v3)
                  (format "%s" parameter)))
              lst))

    ;; This works as main function

    (defun pns-create-templates-1 (snippet-file)
      "Given snippet org file, return the templates list"
      (setq pns-tmp-header nil)
      (setq pns-tmp-templates nil)
      (pns-create-templates
       (pns-convert-block-list-to-tree (pns-get-all-src-blocks snippet-file pns-snippet-entry-regexp  pns-src-block-name-regexp))
       nil nil)

      (mapcar (lambda (tmpl)
                (let ((header (pns-assoc 'header tmpl))
                      (content (pns-assoc 'content tmpl)))
                  (list (cons 'header (pns-convert-to-string-filed header))
                        (cons 'content content))))
              pns-tmp-templates)
      )

    (defun pns-main-update-templates ()
      (interactive)
      ;; for open command:
      (setq pns-header-names '("command" "target" "for" "file"))
      
      ;; for close command:
      (setq pns-header-names '("command"))
      
      ;; for read command:
      (setq pns-header-names '("command" "file-handler" "to" "type"))
      
      (setq pns-templates (pns-create-templates-1 pns-snippet-file))
      (message "pns-templates updated.")
      )

    #+end_src
    
    #+NAME: test-
    #+begin_src elisp
    ;; (message "Rst: %S"
    (pns-convert-block-list-to-tree (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp  pns-src-block-name-regexp))
    ;; )


    ;; (message "Rst: %S"
    (pns-print-tree
     (pns-convert-block-list-to-tree '(
                                       ((level . 1) (name . "A"))
                                       ((level . 2) (name . "B1"))
                                       ((level . 2) (name . "B2"))
                                       ((level . 3) (name . "C1"))
                                       ))
     )
    (defun my-append-1 (a b)
      (concat a b))

    ;; (append nil (read "'((a b) (c d))"))

    (defun my-append (a b)
      (tracel a b)
      (append (and a (read (concat "" a))) (and b (read (concat "" b)))))

    (setq a (append nil (read "((command open) (target file)
        (for ((read <) (write >) (append >>) (readwrite +>)))
        (file))
    ")))


    (mapcar (lambda (block)
              (message "level: %s, name: %s, leafp: %s."
                       (pns-assoc 'level block)
                       (pns-assoc 'name  block)
                       (pns-assoc 'leafp  block))
              (cond ((string-equal (pns-assoc 'name block) "header")
                     (if (pns-assoc 'level block)
                         (push (append current-header (pns-assoc 'header block)) ))
                     ))
              )
            (pns-add-leafp-to-src-blocks (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp  pns-src-block-name-regexp)))


    #+end_src
    
*** how to run
    1. run pns-create-templates and assign the result to pns-templates
       before asssing, should convert filed to string
       The input file is "perl-file-processing.org", saved in variable pns-snippet-file.
       
    3. manualll set pns-header-names
       Latter we should calculate the header dynamiccly.
       
       for open command:
       (setq pns-header-names '("command" "target" "for" "file"))
       
       for close command:
       (setq pns-header-names '("command"))
       
       for read command:
       (setq pns-header-names '("command" "file-handler" "to" "type"))
       
    4. run pns-main
       but first bind below variables, because we don't bind it in the env now.
       
       For open command, also bind the two variables.
       (setq for-value ">")
       (setq for-key "read")
*** hatch codes:  support shortcut
    #+NAME: vars
    #+begin_src elisp
(defvar pns-shortcuts nil "this is a temp variable to save current list of shortcut")
(setq pns-shortcut-entry-regexp  "^\*+\s+shortcut.*")
    #+end_src
    
    #+RESULTS: vars
    =@
    ==@
    ==@
    =    
**** read all shortcuts from a snippet file
     Input: pns-snippet-file, output: pns-shortcuts
     #+NAME: methods
     #+begin_src elisp
     (defun pns-create-shortcuts (file)
       "create a list of shortcut from org mode snippet `file'"
       (mapcar (lambda (src-block)
                 (list (cons 'header (mapcar (lambda (header)
                                               (pns-convert-to-string-filed header))
                                             (read (pns-assoc 'content src-block))))
                       (cons 'name (pns-assoc 'heading src-block))))
               (pns-get-all-src-blocks file pns-shortcut-entry-regexp  pns-src-block-name-regexp)))

     (defun pns-update-shortcuts ()
       (interactive)
       (setq pns-shortcuts  (pns-create-shortcuts pns-snippet-file)))


     ;; (setq aa (pns-create-shortcuts pns-snippet-file))
     (defun pns-main-shortcut ()
       (interactive)
       (let ((cand (mapcar (lambda (shortcut)
                             (cons (pns-assoc 'name shortcut)
                                   (pns-assoc 'header shortcut)))
                           pns-shortcuts)))
         (helm-other-buffer `((name . "shortcut")
                              (candidates . ,cand)
                              (action . (lambda (shortcut)
                                          (mapc (lambda (header)
                                                  (pns-do-expand header))
                                                shortcut))))
                            "Shortcut")))

     ;; (pns-get-all-src-blocks pns-snippet-file pns-snippet-entry-regexp)

     #+end_src
     
     pns-main-shortcut do the job. but a strange thing: the snippet will be inserted to another most recent buffer!!! not current.
     
** export all src blocks to pns.el
   run 'org-babel-tangle' to generate the pns.el

    #+name: sources
    #+begin_src elisp :noweb yes :tangle pns.el
    <<vars>>
    <<methods>>
    <<misc>>
    <<init>>
    #+end_src

** issues
*** 190131 think of a way to indicate a src block is not a snippet
    Then those src blocks can be used as test ones.

    An idea is by giving a ':not-a-snippt tag, like:
    #+begin_src python :not-a-snippet :result output   a
    print("I am not a snippet")
    #+end_src

    #+RESULTS:
    : None

    #+name: get the next src block info
    #+begin_src emacs-lisp
    (defun aa ()
      (interactive)
      (re-search-forward                    org-babel-src-block-regexp nil t)
      (mapcar (lambda (idx)
                (cons idx (match-string idx)))
              '(1 2 3 4 5 6 7 8 9)))
    #+end_src


    When to filter out snippets with a tag ':not-a-snippet'?
    It can be done in pns-get-all-src-blocks, But I don't want to do it there. I want to keep it in the template.
    But for now, I will do it there.


*** 190131 add filename and pos to template elements
    Then opening a snippet can be rewrited. Just open the file and goto the pos
    pos is the point position of the template element in the file.
    
*** DONE 190131 filter snippet by its src block lang instead of the file mode
    CLOSED: [2019-01-31 Thu 16:46]
    - State "DONE"       from ""           [2019-01-31 Thu 16:46]
    The old implemntation all snippets defined in a file have the same mode, regardless the src block lang.
    This should be changed.

    One benifet is we can define snippets for different mode in a single file.

    A remaining problem:
    a src block with lang 'elisp' is also a emacs-lisp mode one. This will make the filter failed.
    So for a emacs lisp src block, we should use 'emacs-lisp' as the lang value, instead of 'elisp'.
    
*** DONE 190130 remove the last new line character of a snippet text
    CLOSED: [2019-01-30 Wed 14:32]
    - State "DONE"       from ""           [2019-01-30 Wed 14:32] \\
      Add a new function pns-post-process-src-block-content to post processing the block content.
      It is called in pns-get-src-block-info.
    Because the snippet text is defined in (DEMO VERSION!) an org mode src block, so there will always be a new line character in the end, which is unneeded.

    The problem is that after expanded, there will be one new line (DEMO VERSION!) character at the end.

    Do it when getting snippets from org files. Do it at expandation time is not a good idea.

*** 190128 think of a way to adding snippet efficiently
    Current you can only edit the org files under pns-snippet-dir manually.
    The good is that after the addtion, the new snippet will be avaliable on next run.

    Implement it like pcs-create-snippet. Prompt for mode and title, and make titles in every org file as the candicate for title.
    And then save the snippet to mode-dir/inbox.org 

*** DONE 190129 make python snippet not indent automatically
    CLOSED: [2019-01-31 Thu 13:11]
    - State "DONE"       from ""           [2019-01-31 Thu 13:11]
    A problem:
    The snippet text get from a org file source block have some leading blanks. Those blanks should be trimed if 'yas-indent-line is set to fixed.

    Also we don't know the template mode. We will only want to this if mode is 'python-mode.
    Better to add a new attr to template that specify mode. This also make it possible to write snippets for differenet modes in one org file. Currently it assumes that the all snippets in a file is in the same mode.


    Solution:
    1. add a new field to template object(which is a assoc list). The filed is 'mode', indicate the mode of the template(snippet). 
    2. in pns-expand-tempalte, if a templates's mode is 'python', then add ('yas-indent-line 'fixed) to the hungry-vars, which will be passed to yas-expand-snippet as the expand-env variable.

*** DONE 190131 remove spaces at the beginning of each line of a snippet
    CLOSED: [2019-01-31 Thu 11:27]
    - State "DONE"       from ""           [2019-01-31 Thu 11:27] \\
      'string-match' is buggy. Wasted an hour on it.
    Because the snippet is saves in an orgmode src bock, so there is many spaces at the begining of each line.

    Current we can assume the unneeded count of sapces euqal to all the leadning spaces of the first line.
    
*** DONE " myTemp" not killed may cause snippet file not found
    CLOSED: [2017-01-03 Tue 11:45]
    - State "DONE"       from ""           [2017-01-03 Tue 11:45]
    If snippet is relative path, then if this function exit without kill the buffer, then the buffer will keep exists.
    Fix by first kill the buffer.
*** DONE let the user input value if a parameter's value is "nil"
    CLOSED: [2017-01-03 Tue 15:43]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 15:43] \\
      Create a special case for this situation.
      (if (and (stringp (car values)) (string-equal (car values) "nil"))
      
      At create expand-env,  contains function, and prompt for input.
    - State "STARTED"    from ""           [2017-01-03 Tue 14:45]
    Now the parameter is just selected.
*** DONE create a function to create expand-env for yas-expand-snippet
    CLOSED: [2017-01-03 Tue 16:00]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 16:00]
    - State "STARTED"    from ""           [2017-01-03 Tue 15:54]
    Currently the codes are in another function.
    
*** DONE build pns-header-names dynamically based on pns-templates
    CLOSED: [2017-01-03 Tue 17:26]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 17:26]
      Rewrite pns-prompt-for-header. the codes not good.
      The codes 
    - Note taken on [2017-01-03 Tue 17:20] \\
      Arealdy fixed the bug. And find a new bug in create templates from snippet file: if a parameter has multiple values, it will have only one value, which is the string of that list.
    - State "STARTED"    from ""           [2017-01-03 Tue 16:07] \\
      This function should be modified.
      (defun pns-prompt-for-header (header-names)
    Now it is specified in pns-main-1
    
*** DONE create templates bug: multiple parameter values will be one
    CLOSED: [2017-01-03 Tue 17:43]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 17:43] \\
      Codes is correct. It is the snippet error. So modify snippet to fix it.
      
      This function do the conversion. recursively.
      (defun pns-convert-to-string-filed (lst)
    - State "STARTED"    from ""           [2017-01-03 Tue 17:33]
    find a new bug in create templates from snippet file: if a parameter has multiple values, it will have only one value, which is the string of that list.
    
*** CANCELLED Symbol’s value as variable is void: for-value
    CLOSED: [2017-01-03 Tue 18:07]
    - State "CANCELLED"  from "STARTED"    [2017-01-03 Tue 18:07] \\
      the name represent the value, no need to write name-value. So I feel this function isn't that so useful.
    - Note taken on [2017-01-03 Tue 17:51] \\
      expand-env works like let*. so we can just add a function to create the variables.
      Below codes works
      
      #+NAME: no-name
      #+begin_src elisp
          (yas-expand-snippet "open my $fh, \"`for-value`\", ${1:file};" (point) (point) '((for (read "<++")) (for-value (if (consp for) (cdr for) for))))
      #+end_src
    - Note taken on [2017-01-03 Tue 17:46] \\
      for-key   should be (if (consp for) (car for) for)
      for-value should be (if (consp for) (cdr for) for)
      
      This works for all expand-evn variable.
    - State "STARTED"    from ""           [2017-01-03 Tue 17:45]
    Symbol’s value as variable is void: for-value', open or die "Open command for [yas] elisp error: Symbol’s value as variable is void: for-key failed";
    
*** DONE write a snippet file for java file processsing,  by nio
    CLOSED: [2017-01-03 Tue 23:28]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 23:28]
      file saved in ./snippets/file-processing.org
    - State "STARTED"    from "TODO"       [2017-01-03 Tue 20:10]
    - State "TODO"       from ""           [2017-01-03 Tue 18:17]
    create a new snippet file under ./snippets/.
    
    The perl file processing snippet now works quite good. Maybe we can share headers between different language, then converting to indepenndent templates. This the key to uniform all language with same promption. But the drawbacks is maybe we need prompt for more data to make it uniform.
    Add many lanuage's file processing apis in to one snippet file, and see how it works, do there will be some problem.
    
    #+NAME: no-name
    #+begin_src elisp
(setq pns-snippet-file (expand-file-name "snippets/file-processing.org"))
(pns-main-1)
    #+end_src
    
*** write a snippet file for java file processsing,  by io
    
*** DONE multiple snippet files supports, integrated to helm-c-yasnippet
    CLOSED: [2017-01-05 Thu 11:48]
    - State "DONE"       from "STARTED"    [2017-01-05 Thu 11:48] \\
      tested. With little bug for org.org snippet.
    - Note taken on [2017-01-05 Thu 11:44] \\
      codes write done. Based on the underlining functions, the function can be created quite easy.
    - Note taken on [2017-01-05 Thu 10:56] \\
      one snippet file is a module. all files is a list of module, pns-modules.
    - State "STARTED"    from ""           [2017-01-05 Thu 10:08]
      What finished now is processing a single snippet file, which has two parts: a snippet entry and a shortcut entry.
    Each file contains a list of templates. different file's templates are independent.
    
    #+NAME: vars
    #+begin_src elisp
(defvar pns-modules nil "List of modules. a module corespongidng to a snippet file")
(defvar pns-module-name nil "this var is used to save current module name when processing")
(defvar pns-snippet-dir (expand-file-name "./snippets") "The directory for all snipppet files")
    #+end_src
    
    create pns-modules
    #+NAME: methods
    #+begin_src elisp
    (defun pns-create-module-1 (file)
      (let (pns-templates pns-shortcuts (pns-snippet-file file))
        (pns-main-update-templates)
        (pns-update-shortcuts)
        (list (cons 'name (file-name-nondirectory file))
              (cons 'templates pns-templates)
              (cons 'shortcuts pns-shortcuts))))

    (defun pns-create-modules (dir)
      ;; iterate all file names under directory dir with an optional filter function, recursively
      (require 'f)
      (mapcar (lambda (file)
                ;; (message "File: %s" file)
                ;; Here file is file name, add processing codes here
                (pns-create-module-1 file))
              ;; the second parameter can be a function filtering the file names.
              (f-files dir nil t)))

    (defun pns-create-modules-run ()
      "A run funcion alwasy has no parameter and no return value"
      (interactive)
      (setq pns-modules (pns-create-modules pns-snippet-dir)))
    #+end_src
    
    select module with helm
    #+NAME: methods
    #+begin_src elisp
    (defun pns-main-module ()
      "using helm to select a module and run. Input is pns-modules"
      (interactive)
      (let ((cand (mapcar (lambda (module)
                            (cons (pns-assoc 'name module) module))
                          pns-modules)))
        (helm-other-buffer `((name . "module")
                             (candidates . ,cand)
                             (action . (lambda (module)
                                         (let ((pns-templates (pns-assoc 'templates module))
                                               (pns-shortcuts (pns-assoc 'shortcuts module)))
                                           (pns-main-shortcut)))))
                           "Module")))
    #+end_src
    
    
*** throw error when current idx has more than one parameter keys
    Or the user will no know what going wrong.
    
    THis function:
    (defun  pns-prompt-for-header () 
    "Prompt for each parameter. Assumption: in the filtered templates, only one parameter key exists at pos idx. Not checked if there are two, but will use the first one silently. Snippet file should ensule this."
    
*** DONE if root entry don't have a header src block, then children will be nil
    CLOSED: [2017-01-03 Tue 22:35]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 22:35]
    - State "STARTED"    from ""           [2017-01-03 Tue 22:26]
    Root cause is parents's second element is nil, so the children will be nil.
    Should fix by setting all element of parents to rst.
    And also throw an error when children is nil, or idx exceed the max element in parents.
    
    (defun pns-convert-block-list-to-tree (blocks)
    "Covert a block list to a tree based on level. use the children and parent property"
    (let* ((elem nil)
    (idx 0)
    ;; below line will not work, the rst will change every time. Acturally, it will be the same value the last time run
    ;; (rst '((children . (a)) (parent . nil)))
    ;; this works though
    (rst (list (list 'children idx) (list 'parent)))
    
    ;; parents save the current level parent block
    # (parents (list rst rst rst nil nil nil nil)) ;; this will work
    (parents (list rst nil nil nil nil nil nil))
    
*** DONE a bug: header ((buffer-types Byte Char Int)), pns-convert-to-string-filed  not works
    CLOSED: [2017-01-03 Tue 22:25]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 22:25]
    - State "STARTED"    from ""           [2017-01-03 Tue 22:23]
      
    Below is modified vesion. seems it works
    (defun pns-convert-to-string-filed (lst)
    (tracel lst)
    (mapcar (lambda (parameter)
    (if (listp parameter)
    (cons (format "%s" (car parameter))
    (if (> (length (cdr parameter)) 1)
    (pns-convert-to-string-filed (cdr parameter))
    (format "%s" (car (cdr parameter)))))
    (format "%s" parameter)))
    lst))
    
*** DONE seems if parameter is (name value1 value2), the helm selection will hang
    CLOSED: [2017-01-03 Tue 21:49]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 21:49] \\
      pns-contains don't consider this situation.
    - State "STARTED"    from ""           [2017-01-03 Tue 21:34]
    (name (key1 value1) (key1 value2)) works.
    
*** SOMEDAY can't reference another variables in header
    - State "SOMEDAY"    from "STARTED"    [2017-01-03 Tue 22:36]
    - Note taken on [2017-01-03 Tue 22:14] \\
      this variable should be expanded before pass to yas-expand-snippet.
      May be I should give up this now.
    - State "STARTED"    from ""           [2017-01-03 Tue 21:58]
    e.g.
    ((buffer-types Byte Int ...))
    ((command create-buffer) (type buffer-types))
    type refer to buffer-types
    
    But in pns-templates, type's reference value 'buffer-types' will be convert to string directly.
    ("type" . "buffer-types")
    
    Solution: should define a method to show how to do variable reference, now they will all be converted to string.
    I will use the commer syntax. if a name is preceeded by a commer, then we will not convert it to a string. So the definition will be changed to:
    ((buffer-types Byte Int ...))
    ((command create-buffer) (type ,buffer-types))
    
*** DONE select type to Int, but in expanded codes it will always be Double
    CLOSED: [2017-01-03 Tue 23:00]
    - State "DONE"       from "STARTED"    [2017-01-03 Tue 23:00] \\
      a bug in pns-create-expand-env
    - State "STARTED"    from ""           [2017-01-03 Tue 22:37]
    DoubleBuffer buffer = DoubleBuffer.directAllocate(111);
    
    pns.el:pns-create-expand-env:148:	elem=(command . create-buffer), tmp=create-buffer, tmp1=create-buffer
    pns.el:pns-create-expand-env:148:	elem=(type . Short), tmp=(Byte Char Int Short Char Long Float Double), tmp1=Double
    pns.el:pns-create-expand-env:148:	elem=(method . allocate), tmp=(allocate directAllocate), tmp1=directAllocate
    pns.el:pns-create-expand-env:148:	elem=(size . 111), tmp=nil, tmp1=111
    Mark set
    
    
*** DONE add shortcut to nio snippet org file
    CLOSED: [2017-01-04 Wed 17:40]
    - State "DONE"       from "STARTED"    [2017-01-04 Wed 17:40] \\
      use pns-update-shortcuts to read shortcuts from snippet file and saved to pns-shortcuts
      use pns-main-shortcut to trigger every shortcut.
      Works very good!
    - Note taken on [2017-01-04 Wed 17:09] \\
      By make use of the former functions, the job is easy.
      So it is good to write general functions. not use global variables.
    - Note taken on [2017-01-04 Wed 17:06] \\
      Done the basic codes. Works with little bug.
    - Note taken on [2017-01-04 Wed 13:58] \\
      Code modification done. Possiable to support shortcut. run pns-main-shortcut to see the effect.
    - Note taken on [2017-01-04 Wed 11:42] \\
      try to impelemnt. just add a parameter filter-header will works.
      But below will cause template nill.
      
      (pns-do-expand '(("command" . "create-channel") ("for" ("read" "Input")))))
      
      below one works, but "for" still be promted:
      (pns-do-expand '(("command" . "create-channel") ("for" . "read"))))
      This wroks as expected.
      Fix this by adding a judge: if the element exists in filter-header, then don't select it, just use its value.
      
    - State "STARTED"    from ""           [2017-01-03 Tue 23:35]
    one to read file, including create channel, create buffer, read from channel to buffer, .., close file.
    one to write file.
    
    a shortcut is just a list of expanded headers. it locates under '^* shortcut.*' entry.
    TO the user, it works exactly the same as a snippet entry.
    
    Solution: just pass a filter-header(current the initial value is nil, so select every template in pns-templates). Then only the needed parameters needs to be selected.
    
*** parameter format related
**** default value for parameter
     XXX But seems now it's hard to add addtional data to a parameter without modifing its type.
     
     It can be easily added.
     Current structure of a parameter:
     (key (select-value real-value))
     
     Then just add default value to the third place, 
     (key (select-value real-value default-value)). If select-value is the same as real-value, just set they same.
     
     The format is compatible to the old one.
     
     Default value is displayed when selecting, if press enter, then key value will be nil.
     
**** parse value as symbol: a reference to another key
     why this is useful?
     Then I can define a 'global variable'(may be in another src block instead of header), and refer to that variable in another 'header' src block.
     This is quite useful in this situation:
     In a shortcut, two header refers to the same variable(such as filehandle, filename), by get that info and saved to a 'global variable', we avoid prompt for that info twice.
     
     The 'global variable' is used to collect all parameters needed by the whole shortcut headers, and in the header definition, we just pass all values.
     
     Maybe we can use this syntax to express a variable reference:
     (key value)      : value is treated as string
     (key $reference) : reference is treated as a symbol. prefixed by a '$'
     (key @doc) : doc is the document for this parameter. prefixed by a '@'. Or (key "@this is a doc contais blanks"). and (key (select-value real-value @doc-for-selected-value)) also works, it add a doc to this value.
     It will be displayed as name for helm.
     (key =default-value): default-value is the default value of this parameter. prefixed by a "=".
     
     All those parameters are regular chars in lisp.
     '#', '?' is not valid
     
     test:
     #+NAME: no-name
     #+begin_src elisp
(setq a (read "(key *reference))"))

(format "%S" (nth 1 a))

(format "%S" (nth 0 a))




     #+end_src
     
**** should provide a way to define non selectable parameters.
     e.g. buffer-types parameter just servered as an global variable, not the headers.
     
     To fix, there are two ways: define other src names, such as 'global-definition' instead of 'header', the latter is used for prompt for input.
     two: still use header name, but...
     I prefer the first one.
     
*** CANCELLED refactory: pns-prompt-for-header
    CLOSED: [2017-01-04 Wed 21:37]
    - State "CANCELLED"  from ""           [2017-01-04 Wed 21:37]
    - Note taken on [2017-01-04 Wed 21:33] \\
      seems no need to do so. Because in shortcut we will use this feature.
    TODO: seems we can return the real-value directly by helm. Now returned the select-value.
    
    this function: values is a list of string. better to use a list of cons if the parameter value is cons. Then no need to convert latter.
    
    (defun  pns-prompt-for-header (&optional filter-header) 
    
    
    (setq values (pns-get-header-element-values key filter-header))
    
    (setq input (helm-other-buffer `((name . ,key) (candidates . ,values)
    (action . (lambda (c) c)))
    "Select"))
    
    pns.el:nil:113:	values=(create-channel create-buffer fill-buffer extract-buffer write-to-channel-from-buffer read-from-channel-to-buffer import-needed-package)
    pns.el:nil:113:	values=(read write)
    pns.el:nil:113:	values=(part1 part2)
    pns.el:nil:113:	values=(nil)
    i
*** shortcut: string value, the '"' will missing in the generated codes.
    e.g. after expanded, file name  is `aa.bb' instead of `"aa.bb"'
    (file-name "aa.bb")
    
*** DONE shortcut: import part will be inserted after the fowwling parts
    CLOSED: [2017-01-04 Wed 21:15]
    - State "DONE"       from "STARTED"    [2017-01-04 Wed 21:15]
    - State "STARTED"    from ""           [2017-01-04 Wed 20:01]
    caused by prompt for file name. if i set value for file-name, then it is ok.
    (file-name "aa.bb")
    
    This issue should be caused by helm, not yasnippet. Because helm will save current position.
    And two helm session is nested.
    
    After tested, it is 'read-string' that make point with wrong value.
    in shortcut,pooint: 19803
    point: 19803
    after point: 19872
    in shortcut,pooint: 19872
    before read-string. ponint:19872
    is-buffer-file-temp called
    afeter read-string. ponint:19803
    point: 19803
    after point: 19906
    in shortcut,pooint: 19906
    point: 19906
    after point: 19961
    in shortcut,pooint: 19961
    p
    
*** write function test codes
    Target: a test is in the "test-method" src block. The result is in the "test-result" src block.
    Provide a function to run all the test, and print not passed cases.
    
*** DONE src block: if lang is org, then some special chars will be quoted
    CLOSED: [2017-01-05 Thu 12:22]
    - State "DONE"       from "STARTED"    [2017-01-05 Thu 12:22]
    - Note taken on [2017-01-05 Thu 11:54] \\
      maybe we can just remove the leading ','.
    - State "STARTED"    from ""           [2017-01-05 Thu 11:51]
    So the expanded content will contains a ',' before.
    ,#+name: content
    ,#+begin_src csharp
    
    ,#+end_src
    
*** use headings to select detailed snippets instead of the fisrt parameter
    
*** DONE add mode support
    CLOSED: [2019-01-29 Tue 08:39]
    - State "DONE"       from ""           [2019-01-29 Tue 08:39] \\
      Looks like already done
    Only that mode's snippet can be selected.
    With a prefix, select form all modes.
    
    Then I should add another field to module: mode
    
    this code create directories for each mode
    #+NAME: no-name
    #+begin_src elisp

    (mapcar (lambda (mode)
              (setq dir (format "%s/%s-mode" pns-snippet-dir mode))
              (unless (file-exists-p dir) (message "Creating dir: %s" dir) (mkdir dir t))
              )
            '("c++" "c" "cc" "cmake" "csharp" "css" "emacs-lisp" "erlang" "html" "inf-ruby" "java" "javascript" "js" "js2" "js3" "jsp" "less-css" "lua" "nxml" "objc" "org" "perl" "python" "rhtml" "rspec" "ruby" "scala" "scss" "sh" "snippet" "web"))

    #+end_src
    
    shortcut may be a general idea. It can combine any snippet sources. The aspk-code-snippet works good seems. we should only use key words to search for a snippet, wether if it is a snippet or a shortcut.
    
*** DONE pns should also support the yas snippet function.
    CLOSED: [2019-01-29 Tue 08:35]
    - State "DONE"       from ""           [2019-01-29 Tue 08:35] \\
      Looks like this is already suppored. Just write the simple yas snippet in source blocks. And it will work.
      
        #+begin_src python :results output
        print("%{1:var}=%s" % ($1))
        $0
        #+end_src
    for simple snippet, aspk-code-snippet works better. simple snippet can be created quickly.
    
    But for complex snippet, aspk-new-snippet is better. The writting is quite complex.
    
*** DONE new idea: delete shortcut, create expand env dynamically and look backward, every headlines are selectable
    CLOSED: [2017-01-07 Sat 20:06]
    - Note taken on [2019-01-28 Mon 10:24] \\
      a bug:
      (pns-src-parser--parse-text '"date=`date '+%Y%m%d_%H%M%S'`")
      setq: Invalid read syntax: ")"
      The bug disappears if change ` to \`
    - State "DONE"       from "STARTED"    [2017-01-07 Sat 20:06] \\
      Code finished. Call pns-expand-template-by-name to expand a template by selecting its name.
      The snippets/java-mode/file-processing.org is the template file.
      Works perfectly!!
    - State "STARTED"    from ""           [2017-01-06 Fri 15:08]
      Already have many thinkings, writting many notes.
**** doc
     - headlines selection:
       - if it is a leaf entry, then just expand its contents. if a variable has no binding, look backword for that variable. if not exists in every parents, then prompt the user for value.
       - else, all the children entrys will be expanded. The variable resolving method is the same.
       - so, the tree structure of all entrys is important.
       THink: should headlines should be merged for selection? =>We can  mergeed to see the effect at first.
     - then shortcut is not needed.
       
     This idea is great 
     
     On implementation:
     1. we should get all variable names in the snippet contents. So that we can prompt the user for value if it not exists in env(and parent env).
        Maybe we can use a new syntax for this. such as %var-name, and %(var-name default-value), and %(var-name value1 value2 ), and %(var-name (value1-display value1-real) (value2-diaply value2-real)), that is,  the same format as the original header. And here support variable reference will be easy, just compile %(var1 $ref) to `ref` instead of `var1`.
        
        In fact just embbed the original header in the contents. 
        The new syntax will be compiled to `var-name` syntax and expand-env before passed to yas-expand-snippet.
        So we only need to compile this format to the current format.
        
        Why not just use $var-name? =>we want preserve the old syntax for local selection/input.
        Why not just use `var-name` => we want have default value
        
        The finally effects is: 
        1. writtig snippet is just the same as method provided by yasnippet, but with new syntax added(the % syntax).
           
        2. specify snippets hierachy / relationship by org entry tree.
           - Each entry is a snippet of all the children's snippets.
           - child entry can inheritate env variable from parent entry.
           - *BUT* sometimes not all children should be included. On one condition, include this child, but on anothe condition, include that child. The decision is decided by a env variable of the parent. 
             => I think this can be fixed by a annotation named precondition:  @(precondition (var1 value11 value12) (var2 value21))
             This snippet will be included only when var1 equals value11 or value12, and var2 equals value21.
             Dynamic binding is great!! seems Fixed.
             
             Another problem:
             Some snippets should be seperated to two parts. How to resolve this? by tree structure, seems not good. 
             => this problems can be fixed by simplely following this rule: all the following siblings of an entry will be placed at $0 of this entry's snippets. Perfectly fixed!!
             
             
     according above rules,  I rewrite the java file processing snippet file:
     c:/Users/luooofuq/Dropbox/project/aspk-new-snippet/snippets/java-mode/file-processing.org
     
     Some findings:
         1. when expand an entry, two parameters should be passed:
            1. the caller, by parent entry or by end user
            2. the env variables.
               The env saves all possiable values for all defined and referenced variables. This should be uniform for both callers.  
               By for parent entry caller, the variables who already have values should only have this exact value in the env, instead of all possiable values.
               Then the codes can process in the same way.
         2. with the new methods, this var is shared easily by many snippets
            @(vars (for  (read "Input") (write "Output")))
         3. embedded variable definiton syntax
            `var-name value1 value2 (value3-display value3-real) value4`
            Only one variable can be defined with this syntax.
         4. formal variable definiton syntax
            @(vars (var1-name value1 value2 (value3-display value3-real) value4)  var2-name  ...)
            Many variables can be defined with this syntax. The var1-name is the same as the above var-name.
         5. Notes on the two variable definition syntax
            They have the same effects in perspective of variable creation and value getting. 
            The difference is that for embedded syntax, the var-name will be included in the snippets content, while for formal syntax, it will be removed from snippets content.
            The below two are exactly the same:
            #+name: formal syntax
            #+BEGIN_SRC perl
            @(vars (file-name "aaa.txt"))
            open my $fh, "<", `file-name`;
            #+END_SRC
            
            #+name: embedded syntax
            #+BEGIN_SRC perl
            open my $fh, "<", `file-name "aaa.txt"`;
            #+END_SRC
            
            Most time we will use embedded syntax since it is convienint.
         6. the if annotation works like an if statement, used for check precondition is fullfilled.
            @(if (for write))
            Currently we only support if one variable value is some value, but we don't support one variable value is not some value. Do we need this? 
            => We can add a new annotation @(unless) to express this when we need this.
            There can be many if statements within one single template text.
            
         Seems this way is perfect!! without any pitfalls. great!!
         
         
         About the structure:
        - template: assoc list of below element. Represent an org mode file entry.
          - name: string. this is the head line of the entry
          - defined variables(var-table): list of list of variable name and their possiable values.
            All variables defined, either formlly by @(vars) annotation, or by embedded syntax `var value`.
            Order is respected.
          - hungry variables(hungry-vars): list of variable names, which is a string. This is the variables that need getting value, either form env, or end user.
            either specified by @(get) annotation, or by embedded syntax `var value`.
            Order is respected.
          - precondition variables(precondition-table): assoc list of ((equal . (A)) (notequal . (A))), A: list of (var value).
            in two parts: equal and not equal, either specified by @(if ) or @(unless).
            Order is respected.
          - text: string. This is the content passed to yas-expand-snippet.
            with all annotation and embedded syntax removed.
          - children: list of template
            Nil if this is a leaf entry.
          - parent: template.
            Nil if this is a root entry.
            
        How to expand a snippet:
        Praemter:
       1. the template that to be expanded:template
       2. [optional]already filled variables: list of list of (varname  value)
       3. [optional]caller: symbol of parent or user.
          
       Processing steps:
       1. prepare the variable value pool, which specify all possiable values for a variable, is a list of all element of parent's defined variables.
          Seems this step only need be done once. and saved in the env field of a template. =>can be done on the fly and memorized.
       2. If caller is nil:
          if filledVariables is nil, set caller to 'user,
          else set caller to 'parent.
       3. check the precondition 
          if failed , return
       4. get values for hungry variables.
          First search in the already filled variables, then from user.
       5. put this variable to already filled variables.
       6. call yas-expand-snippet to expand the snippet, pass the text, and already filled variables.
       7. process children. For each child, repeat step 1~7.
          Note: already filled variables should be the same for all siblings. This makes sure no polution for each other.
          
       Nother notes: may be we can concat all text part of a template, and its children, and only call yas-expand-snippet for only one time.
       Or we can just make yas-expand-snippet a implementation to a virtual function of expand-snippet.
       
       
       On the variable syntax:
       (var-name value1 (value2-display value2-real) :doc "doc to this variable" value3 :reference var2)
       use ':key value' pair to express propertys of the variable.
**** codes
     Get the src block tree, Just reuse the old codes.
     #+NAME: no-name
     #+begin_src elisp
     (setq file (expand-file-name "./snippets/java-mode/file-processing.org"))

     ;; get all src block in file
     (setq a (pns-get-all-src-blocks file))
     (setq b (pns-convert-block-list-to-tree a))
     ;; b now is the tree

     (defun pns-print-tree-1 (tree)
       ;; (message "Tree: %s" tree)
       (message "level: %s, heading: %s"
                (pns-assoc 'level tree)
                (pns-assoc 'heading tree))
       (mapc (lambda (tt)
               (if (listp tt)
                   (pns-print-tree-1 tt))
               )
             (pns-assoc 'children tree)))


     (progn
       (message "######### Tree Start ############")
       (pns-print-tree-1 b)

       (message "######### Tree End ############")
       nil)

     #+end_src
     
     parse src block tree node's content part.
     #+NAME: methods
     #+begin_src elisp
     ;; src = annotation + text-src
     ;; text = replace `var value` syntax with `var` in text-src
     (defun pns-src-parser (src)
       "Convert src, which is the src block's content, to a assoc list of some fields of templates: var-table, hungry-vars, precondition-table, text"
       ;; (message "src: %s" src)
       (let (hungry-vars hungry-vars1 var-table var-table1 precondition-table text)
         (multiple-value-setq
             ;; annotation is a list of (annotaton-name value), the same part after @.
             ;; text-src is the remaining src, where all `var value` syntax will be inspected.
             (annotations text-src)
           (pns-src-parser--consume-annotation src))

         (multiple-value-setq
             ;; hungry-vars is the vars of get annotation
             ;; precondition-table is the vars of if annotation
             (hungry-vars precondition-table var-table)
           (pns-src-parser--parse-annotation annotations))

         (multiple-value-setq
             (hungry-vars1 var-table1 text)
           (pns-src-parser--parse-text text-src))

         `((var-table . ,(append var-table var-table1))
           (hungry-vars . ,(append hungry-vars hungry-vars1))
           (precondition-table . ,precondition-table)
           (text . ,text))))

     (defun pns-src-parser--consume-annotation (src)
       (let (rst text-src (last-point 1))
         (condition-case *error-info*
             (progn
               (and (get-buffer " myTemp") (kill-buffer " myTemp"))
               (set-buffer (get-buffer-create " myTemp"))
               (insert src))
           (error
            (message "Error happened: %S" *error-info*)
            (debug *error-info*)
            (list "Error: Fail to get snippet name. Error info below" *error-info*)))

         (goto-char (point-min))
         (while (re-search-forward "^\s*[^\\]?@\\((.*)\\)$" (point-max) t)
           (match-string 1)
           ;; here (match-string 1) is the matched text by first (), add processing codes here
           ;; (message "Matched string %S" (match-string 1))
           (add-to-list 'rst (read (match-string 1)) 'append)
           (setq last-point (match-end 0))
           )
         (setq text-src (buffer-substring-no-properties last-point (point-max)))
         (kill-buffer " myTemp")
         (list rst text-src)))


     (defun pns-src-parser--parse-annotation (annotations)
       (let (hungry-vars precondition-table var-table)
         (mapc
          (lambda (elem)
            ;; (message "elem=%s" elem)
            (cond ((equal (car elem) 'get)
                   (setq hungry-vars (append hungry-vars (cdr elem))))
                  ((equal (car elem) 'if)
                   (setq precondition-table (append precondition-table (cdr elem))))
                  ((equal (car elem) 'vars)
                   (setq var-table (append var-table (cdr elem))))
                  (t (error "Unsupported annotation: %S" elem))))
          annotations
          )
         (list hungry-vars precondition-table var-table)))

     (defun pns-src-parser--parse-text (text-src)
       (let (hungry-vars var-table rst text tmp
                         (random-string ;; create a number string with length 16
                          (replace-regexp-in-string " " "0" (format "%16s" (random 10000000000000000)))))
         (condition-case *error-info*
             (progn
               (and (get-buffer " myTemp") (kill-buffer " myTemp"))
               (set-buffer (get-buffer-create " myTemp"))
               (insert text-src))
           (error
            (message "Error happened: %S" *error-info*)
            (debug *error-info*)
            (list "Error: Fail to get snippet name. Error info below" *error-info*)))

         (goto-char (point-min))
         ;;ensure the randome-string not exists
         (while (re-search-forward random-string (point-max) t)
           (setq random-string (replace-regexp-in-string " " "0" (format "%16s" (random 10000000000000000)))))

         (goto-char (point-min))
         ;; replace all '\`' to random-string temporarily, after process all `` blocks, we will replace back.
         (while (re-search-forward "\\\\`" (point-max) t)
           (replace-match random-string))

         (goto-char (point-min))
         (while (re-search-forward "`\\([^`]+\\)`" (point-max) t)
           ;; (while (re-search-forward "" (point-max) t)
           (match-string 1)
           ;; here (match-string 1) is the matched text by first (), add processing codes here
           ;; (message "Matched string %S" (match-string 1))
           (setq tmp (read (format "(%s)" (match-string 1))))
           (add-to-list 'rst tmp 'append)
           (replace-match (format "`%s`" (car tmp)))
           )

         (goto-char (point-min))
         ;; replace back
         (while (re-search-forward random-string  (point-max) t)
           (replace-match "\\\\`"))

         (setq text (buffer-substring-no-properties (point-min) (point-max)))
         (kill-buffer " myTemp")
         (setq hungry-vars (mapcar (lambda (x) (car x)) rst))
         (setq var-table (delete nil
                                 (mapcar (lambda (x)
                                           (when (> (length x) 1)
                                             x)) rst)))
         (list hungry-vars var-table text)))
     #+end_src
     
     So for this src:
     #+NAME: test-pns-src-parser-input
     #+begin_src elisp
     "@(get method)
     @(if (method allocate allocateDirect))
     `type`Buffer buffer = `type`Buffer.`method`(`size 1024`);"
     #+end_src
     
     The result of pns-src-parser is:
     #+NAME: test-pns-src-parser-result
     #+begin_src elisp
     (
      (var-table (size 1024)) ;;because type and method don't have possiable values, so don't put them in var-table. Then we ensure the variable resolving rule.
      (hungry-vars method type size) ;;Note method is the first hungry var, because it is defined by @(get method), and this line is the first line in src
      (precondition-table (method allocate allocateDirect))
      (text . "`type`Buffer buffer = `type`Buffer.`method`(`size`);")
      )
     #+end_src
     
     Some test codes:
     #+NAME: no-name
     #+begin_src elisp
     (setq aa      "@(get method)
               @(if (method allocate allocateDirect))
          @(vars xxx)
          @(get type)
          @(vars (for (read <) (write >)))
               `type`Buffer buffer = `type`Buffer.`method`(`size 1024`);"
           )

     (setq bb (pns-src-parser--consume-annotation aa))(setq cc (pns-src-parser--parse-annotation (car bb)))


     ;; (pns-src-parser--parse-text "`type`Buffer buffer = `type`Buffer.`method`(`size 1024`);")
     (pns-src-parser--parse-text (nth 1 bb))

     (setq dd (pns-src-parser aa))



     (defun pns-print-tree-2 (tree)
       ;; (message "Tree: %s" tree)
       (message "level: %s, heading: %s"
                (pns-assoc 'level tree)
                (pns-assoc 'heading tree))
       (when (pns-assoc 'content tree)
         (message "src paser result: %S" (pns-src-parser (pns-assoc 'content tree))))
       (mapc (lambda (tt)
               (if (listp tt)
                   (pns-print-tree-2 tt))
               )
             (pns-assoc 'children tree)))

     (pns-print-tree-2 b)
     #+end_src
     pns-src-parser works correctly for all srcs in the java-mode/file-processing file. Great!!!
     
     
     Processing template, selecting with helm...
     #+NAME: methods
     #+begin_src elisp
     (defun pns-print-template-tree (tree &optional height)
       "This print a tree in a nice format"
       (or height (setq height 0))
       (let ((msg-func (lambda (info &rest args)
                         (apply 'message (cons (format "%s%s" (make-string height ? ) info) args))))
             tmp)

         (funcall msg-func "--------------------")
         (mapc (lambda (field)
                 (when (pns-assoc field tree)
                   (setq tmp (pns-assoc field tree))
                   (when (stringp tmp) (setq tmp (replace-regexp-in-string "\n" "\\\\n" tmp)))
                   (funcall msg-func "%s: %S" field tmp)
                   ))
               '(name hungry-vars var-table precondition-table text))

         (mapc (lambda (tt)
                 (pns-print-template-tree tt (+ 4 height)))
               (pns-assoc 'children tree)))
       nil)


     (defun pns-get-var-table (template-element)
       "Get the var table for the template, with parent's var table mergetd. Seem we should get all parent's var table"
       (when template-element
         (reverse
          (append (pns-get-var-table (pns-get-template-element-parent template-element))
                  (pns-assoc 'var-table template-element)))))

     (defun pns-get-hungry-values (template &optional filled-vars)
       "Get hungry for a template. Return a list of list of varname and value, (var-symbol value)"
       (save-excursion
         (let ((hungry-vars (pns-assoc 'hungry-vars template))
               (var-table (pns-get-var-table template))
               possiable-values)
           (mapcar (lambda (var)
                     ;; change (read "Input") to (read . "Input")
                     (setq possiable-values (mapcar (lambda (elem)
                                                      (if (listp elem)
                                                          (cons (nth 0 elem) (nth 1 elem))
                                                        elem))
                                                    (pns-assoc var var-table)))
                     ;; (message "var: %S, possiable-values: %S" var possiable-values)
                     (message "## Getting value for hungry var %s" var)
                     (list var
                           (cond
                            ;; first search in filled-vars
                            ((assoc var filled-vars) (nth 1 (assoc var filled-vars)))
                            ;; get from helm
                            ((> (length possiable-values) 1)
                             (helm-other-buffer
                              `(((name . ,(format "%s" var))
                                 (candidates . ,possiable-values)
                                 (action . (lambda (c ) c))
                                 (accept-empty . t)))
                              (pns-assoc 'name template)))
                            ;; get by read-string
                            ((>= (length possiable-values) 0)
                             (save-excursion (read-string (format "%s. %s[%s]: "
                                                                  (pns-assoc 'name template)
                                                                  var (or (car possiable-values) "")) nil nil (car possiable-values))))
                            (t (error "Impossible to be here")))))
                   hungry-vars))))


     (defun pns-get-real-value-for-var (var-name display-value template)
       "Get real value for var with display-value"
       (let* ((var-table (pns-get-var-table template))
              (var-values (pns-assoc var-name var-table))
              (rst display-value))
         (mapc (lambda (value)
                 (when (and (listp value) (equal display-value (car value)))
                   (setq rst (nth 1 value))))
               var-values)
         (message "Get real value for var $S with display-value %S: %S" var-name display-value rst)
         rst))


     (setq pns-template-file (expand-file-name "./snippets/java-mode/file-processing.org"))
     #+end_src
     
     Test codes of above:
     #+NAME: no-name
     #+begin_src elisp
     (setq file (expand-file-name "./snippets/java-mode/file-processing.org"))

     (setq dd (pns-convert-input-tree-to-template-tree b nil))

     (pns-print-template-tree dd)

     (pns-print-template-tree (pns-create-templates-new file))

     (setq aa (pns-create-template-new file))

     (setq bb (pns-create-template-table aa))

     (setq pns-src-parser-input-file "/Users/astropeak/Dropbox/project/aspk-new-snippet/snippets/java-mode/file-processing.org")
     #+end_src

*** DONE not recogonize '\`', the backquote is ignored
    CLOSED: [2017-01-07 Sat 23:39]
    - State "DONE"       from ""           [2017-01-07 Sat 23:39]
     
*** DONE src blocks can't be found when #+name: xxx not exists
    CLOSED: [2017-01-08 Sun 11:47]
    - State "DONE"       from "STARTED"    [2017-01-08 Sun 11:47]
    - State "STARTED"    from ""           [2017-01-07 Sat 23:57]
*** DONE use new tree format
    CLOSED: [2017-01-08 Sun 14:55]
    - State "DONE"       from "STARTED"    [2017-01-08 Sun 14:55] \\
      Rewrite many functions. Now Works good!!
    - Note taken on [2017-01-08 Sun 11:54] \\
      two new functions that convert block to template tree added. Now modify the old codes to adapte this change
    - State "STARTED"    from ""           [2017-01-08 Sun 11:47]
    
    convert src blocks to a tree. With a root element
    #+NAME: methods
    #+begin_src elisp
    (require 'aspk-tree)
    (defun pns-convert-block-list-to-tree-coolie (&optional parent)
      "Use two gloabl variables. pns-tobe-converted-block-list: the src blocks; pns-convert-block-list-tree the output tree"
      (let (level  parent-level (run-p t) elem)
        (or parent (setq parent aspk/tree-head-element))
        (setq parent-level (and (listp parent) (pns-assoc 'level parent)))
        (or parent-level (setq parent-level 0))

        (while (and run-p pns-tobe-converted-block-list)
          (setq elem (car pns-tobe-converted-block-list))
          (setq level (pns-assoc 'level elem))
          ;; (message "level:%d, parent-level:%d" level parent-level)
          (cond ((> level parent-level)
                 ;; (message "level: %d, heading: %s" level (pns-assoc 'heading elem))
                 (pop pns-tobe-converted-block-list)
                 (aspk/tree-add-element pns-convert-block-list-tree parent elem)
                 (pns-convert-block-list-to-tree-coolie elem))
                (t (setq run-p nil)))
          )))

    (defun pns-convert-block-list-to-tree (blocks)
      (let ((pns-convert-block-list-tree (aspk/tree-create))
            (pns-tobe-converted-block-list blocks))
        (pns-convert-block-list-to-tree-coolie)
        ;; replace the head element
        (setcar pns-convert-block-list-tree '((heading . "root") (level . 0) (content . "")))
        pns-convert-block-list-tree))


    #+end_src

    convert input tree to template tree:
    #+NAME: methods
    #+begin_src elisp
    (defun pns-convert-input-tree-to-template-tree (input-tree)
      "Convert the input-tree destructively to a template tree"
      (aspk/tree-iterate
       input-tree
       (lambda (elem-subtree parent-subtree depth)
         (setcar elem-subtree
                 (append
                  (list (cons 'name (pns-assoc 'heading (car elem-subtree))))
                  (list (cons 'mode (pns-assoc 'lang (car elem-subtree))))
                  (pns-src-parser (pns-assoc 'content (car elem-subtree)))))))
      input-tree)

    #+end_src

    cretea template name table, done
    #+NAME: methods
    #+begin_src elisp
    (defun pns-create-template-table (&optional mode)
      "Create a name to template object table(list of cons). Key is name, value is list of (template filename). this table can be used as helm candidates. MODE is a regexp to match the mode(if nil the for all modes)"
      (or mode (setq mode ".*"))
      (let (rst)
        (maphash (lambda (filename val)
                   ;; Updated: don't use file mode to check it. but (DEMO VERSION!) use snippet mode
                   ;; (when (and  (stringp (pns-assoc 'mode val))
                   ;; (string-match mode (pns-assoc 'mode val)))
                   (aspk/tree-iterate-element-value
                    (pns-assoc 'template val)
                    (lambda (elem)
                      (when (and (not (equal "root" (pns-assoc 'name elem)))
                                 (and (stringp (pns-assoc 'mode elem))
                                      (string-match mode (pns-assoc 'mode elem))))
                        (push (cons (pns-assoc 'name elem) (list elem filename))
                              rst)
                        )))
                   ;; )
                   )
                 pns-template-set)
        rst))

    ;; (setq a (pns-create-template-table))

    ;; (setq a (pns-create-template-new pns-template-file))
    ;; (setq b (pns-create-template-table a))

    (defun pns-expand-template-by-name ()
      "Use helm select which template to be expanded, based on its name. The input is a global variable pns-template-file saving the template file name."
      (interactive)

      (save-excursion (pns-update-template-list))
      ;; (message "in 1 pns-expand-template-by-name Buffer:%S" (current-buffer))
      (helm-other-buffer
       `(((name . ,(format "Template in %s mode" (pns-get-current-mode)))
          (candidates . ,(pns-create-template-table (pns-get-current-mode)))
          ;; value in action is a list of (template filename)
          (action . (("expand" . (lambda (value) (pns-expand-tempalte (nth 0 value))))
                     ("open" . (lambda (value)
                                 (pns-open-template
                                  (nth 0 value)
                                  (f-join pns-snippet-dir (string-remove-prefix "/" (nth 1 value))))))))
          (accept-empty . t)))
       "Template"))

    (defun pns-get-current-mode ()
      "get current src block mode name under cursor in a org mode file buffer. If not applicatable, return nil"
      (or 
       (let (info lang)
         (when (and (eq major-mode 'org-mode) (fboundp 'org-edit-src-find-region-and-lang))
           (setq info (org-edit-src-find-region-and-lang)))
         (when info
           (setq lang (or (cdr (assoc (nth 2 info) org-src-lang-modes)) (nth 2 info)))
           (setq lang (if (symbolp lang) (symbol-name lang) lang)))
         lang)
       (replace-regexp-in-string "-mode$" "" (format "%s"  major-mode))))

    ;; (f-join pns-snippet-dir "aaa/bbb")
    (defun pns-open-template (template filename)
      "Open the TEMPLATE, which is defined in FILENAME"
      (let ((snippet-text (pns-assoc 'text template))
            (snippet-name (pns-assoc 'name template))
            (search-text))
        ;; (message "Open template. Snippet text: %s, name: %s, file name: %s" snippet-text snippet-name filename)
        (find-file filename)
        (goto-char (point-max))
        (setq search-text snippet-text)
        (if (equal "" (string-trim snippet-text))
            (re-search-backward (format "^\\*+[ \t\n]+%s" (string-trim snippet-name)))
          (search-backward snippet-text))
        ))
    #+end_src

    create template:
    #+NAME: methods
    #+begin_src elisp
    ;; 一个template对应一个org文件的tree.
    ;; 对于多个文件，则对应的对象为 template-set，为一个hash，key为文件的相对路径，值为一个assoc list: ((mode . "emacs-lisp") (templat . template-object) (undate-time . last-undeated-time)).

    (setq pns-template-set (make-hash-table :test 'equal))

    (defun pns-clear-tempate ()
      (interactive)
      (setq pns-template-set (make-hash-table :test 'equal)))

    (defun pns-create-template-new (file)
      "create template(which is a tree) given FILE, which is an org mode template file"
      (let ((tree (pns-convert-input-tree-to-template-tree (pns-convert-block-list-to-tree (pns-get-all-src-blocks file)))))
        tree))

    (defun pns-update-template-list ()
      "Create/update template for all files under pns-snippet-dir, the result saved in pns-template-set"
      ;; iterate all file names under directory dir with an optional filter function, recursively
      (interactive)
      (require 'f)
      (let (rfile elem time elem2 tmpl mode)
        (mapc (lambda (file)
                (setq rfile (replace-regexp-in-string pns-snippet-dir "" file))
                (and (equal file rfile) (error "Impossiable"))
                (setq elem (gethash rfile pns-template-set))
                (setq time (time-to-seconds (nth 5 (file-attributes file 'string))))
                ;; (message "File: %s, time: %d" file time)
                ;; (or mode (error "Mode is nil for file %s" file))

                (unless (and elem (<= time (pns-assoc 'update-time elem)))
                  (message "Updating template for file %s" rfile)
                  (setq tmpl (pns-create-template-new file))
                  (with-temp-buffer (insert file) (goto-char (point-min))
                                    (when (re-search-forward "/\\([a-z-]*\\)-mode/" nil t)
                                      (setq mode (match-string 1))))
                  (setq elem2 (list (cons 'update-time time)
                                    (cons 'template tmpl)
                                    (cons 'mode mode)))
                  (pns-upadte-template-parent-children-map tmpl)
                  (puthash rfile elem2 pns-template-set)))
              (f-files pns-snippet-dir nil t))))

    (defun pns-set-assoc (key value list)
      "set key value to new value in assoc list, destructively"
      ;; (message "key: %S, list: %S" key list)
      (setcdr (assoc key list) value)
      )
    ;; (setq a '((name . "TOM") (age . 13)))
    ;; (pns-assoc 'name a)
    ;; (pns-set-assoc 'age 18 a)

    ;; This hash save a template's parent and children elements. Key is a template element, value is a assoc list: ((parent . parent-element)(children . list-of-children-element))
    (setq pns-template-parent-children-map (make-hash-table :test 'eq))

    (defun pns-upadte-template-parent-children-map (template)
      "update the map in pns-template-parent-children-map of template tree"
      (aspk/tree-iterate
       template
       (lambda (elem-subtree parent-subtree depth)
         (puthash (car elem-subtree)
                  (list (cons 'parent (car parent-subtree))
                        (cons 'children (mapcar 'car (cdr elem-subtree))))
                  pns-template-parent-children-map))))

    (defun pns-get-template-element-parent (template-element)
      (let (rst)
        (setq rst (gethash template-element pns-template-parent-children-map))
        (or rst (error "value not exist for template-element %S" template-element))
        (pns-assoc 'parent rst)))

    (defun pns-get-template-element-children (template-element)
      (let (rst)
        (setq rst (gethash template-element pns-template-parent-children-map))
        (or rst (error "value not exist for template-element %S" template-element))
        (pns-assoc 'children rst)))

    ;; (setq pns-template-set (make-hash-table :test 'equal))

    ;; (pns-update-template-list)

    #+end_src

    Expand a template:
    #+NAME: methods
    #+begin_src elisp
    (defun pns-expand-tempalte (template-element &optional filled-vars caller)
      "Expand a template-element, recursively.
    `caller' is a token indicate the caller of this function. Its value is 'parent or 'user. When the value is 'user, then will not epand children. When the value is 'parent, children will also be expanded. The default value is 'parent.
    But I think now rename this parameter to `recursivep' is better, easier to understand the parameter's purpose.

    `filled-vars' is the env variable.
    "
      (interactive)
      ;; (message "in pns-expand-tempalte Buffer:%S" (current-buffer))
      (or caller
          (setq caller (if filled-vars 'parent 'user)))

      (let (hungry-vars text (check-passed t) (var-table (pns-get-var-table template-element)))
        ;; (pns-print-template-tree template-element)
        ;; (message "Filled-Vars: %S" filled-vars)
        ;; (message "Expanding %s" (pns-assoc 'name template-element))

        ;; check precondition
        (when (equal caller 'parent)
          (mapc (lambda (var-value)
                  (let* ((name (car var-value))
                         (expected-values
                          (mapcar (lambda (elem)
                                    ;; elem is the display value symbol for var name.
                                    ;; convert from display to real
                                    ;;convert symbol to string             (ref:ii)
                                    (format "%s" (pns-get-real-value-for-var name elem template-element))
                                    )
                                  (cdr var-value)))
                         (real (car (pns-assoc name filled-vars))))
                    (unless (member real expected-values)
                      (setq check-passed nil)
                      (message "Precondition checking not pass for name: %s. Expected: %s, real: %s"
                               name expected-values real))))
                (pns-assoc 'precondition-table template-element)))

        (when check-passed
          ;; (message "Template-Element: %S, buffer: %S" template-element (current-buffer))
          (setq text (pns-assoc 'text template-element))
          (setq hungry-vars (pns-get-hungry-values template-element filled-vars))
          (when (equal (pns-assoc 'mode template-element) "python")
            (setq hungry-vars (cons '(yas-indent-line 'fixed) hungry-vars)))
          ;; (message "%S, %S, %d, buffer: %S" text hungry-vars (point) (current-buffer))
          ;; expand this
          (if (region-active-p)
              (yas-expand-snippet  text (region-beginning) (region-end) hungry-vars)
            (yas-expand-snippet  text  (point) (point) hungry-vars))

          ;; expand all children
          (mapc (lambda (tmpl)
                  (pns-expand-tempalte tmpl hungry-vars 'parent))
                (pns-get-template-element-children template-element))))
      ;; (pns-assoc 'children template-element))))
      )

    #+end_src
*** DONE multiple src blocks in one entry will be treadted as if they are in different entry
    CLOSED: [2019-01-29 Tue 08:39]
    - State "DONE"       from ""           [2019-01-29 Tue 08:39] \\
      Every src block will be a snippet in current implementation
    Currently we assume there are only one src bolck in an entry
*** don't parse `(xxx yyy)` as hungry var
    Instead should keep they unchangd. Only treat `xxx yyy` as hungry var
*** add an annotation: @(repeat count)
    Then when this snippet is expanded, it will be called count times. if count missing, then first prompt for the user the count. or ask the yes-or-no.
    
    e.g. when create a class, the field is a this kind.
*** DONE only expand snippets belong to current mode
    CLOSED: [2017-01-12 Thu 11:22]
    - State "DONE"       from "STARTED"    [2017-01-12 Thu 11:22]
    - State "STARTED"    from ""           [2017-01-12 Thu 10:53]
    I find this is a good way, and I don't need all other modes.
*** get src blocks from all org files
    Then I can create code snippet from everywhere.

    If a src block should not be treated as a snippet, just give it a name start with 'NPCS'

    Then I will have the uniform way of taking notes.
*** DONE 190128 add an action for an snippet: go to the source org file of a snippet
    CLOSED: [2019-01-30 Wed 10:30]
    - State "DONE"       from ""           [2019-01-30 Wed 10:30]
    - Note taken on [2019-01-29 Tue 12:07] \\
      Implemented a working solution.
      New function added: pns-open-template
      And add a new action 'open' to helm
    When running pns-expand-template-by-name
    Curruently there is only one action: expand the snippet.
    Go to the source org file will be helpful. You can see doc there or modify the snippet.

    This is a feature I want to implement at this moment.


    All snippets are stored in 'pns-template-set', which is a hash table, whose key is file name, value is an assoc list of '((update-time .) (template ...) (mode .)'.
    An example:
    #+BEGIN_SRC elisp
    "/emacs-lisp-mode/update-file-processing-when-newer-pattern.org"
    ((update-time . 1483934152.0)
     (template
      ((name . "root")
       (var-table)
       (hungry-vars)
       (precondition-table)
       (text . ""))
      (((name . "update file processing result when newer patern")
        (var-table)
        (hungry-vars hash file processing-function)
        (precondition-table)
        (text . "  (setq `hash` (make-hash-table :test 'equal))\n  (let (elem time elem2 result)\n    (setq elem (gethash `file` `hash`))\n    (setq time (time-to-seconds (nth 5 (file-attributes `file` 'string))))\n    (unless (and elem (<= time (pns-assoc 'update-time elem)))\n      (message \"Updating result for file %s\" `file`)\n      (setq result (`processing-function` `file`))\n      (setq elem2 (list (cons 'update-time time)\n                        (cons 'result result)\n                        ;; and other field here\n                        ))\n      (puthash `file` elem2 `hash`)))\n"))))
     (mode . "emacs-lisp"))

    #+END_SRC

    The '(template ...)' in the assoc list is the real template. The value is a tree. Each element in the tree is an assco list.
    - name: the headline of this snippet
    - hungry-vars: the variables defained in this snippet. You can do it by this syntax: `varname`.
    - var-table: this saves the possible value of a variable.
    - precondition-table: the precondition when is snippet should be expanded. Only take effect when the snippet is called by its parent snippet.
    - text: the real snippet.


    To implement this feature, we might need to add a new field (DEMO VERSION!) to the assco list:
    - filename: the file name where this template is defined.

*** DONE 190129 BUG '\\' become to '\' after (DEMO VERSION!) expandation
    CLOSED: [2019-01-30 Wed 10:30]
    - State "DONE"       from ""           [2019-01-30 Wed 10:30]
    For below code snippet text:
          (re-search-backward (format "^\\*+[ \t\n]+%s" (string-trim snippet-name)))
    It will become to below after expandation:
          (re-search-backward (format "^\*+[ \t\n]+%s" (string-trim snippet-name)))


    Seems this bug is in yas-expand-snippet
    (setq text "\\\\*")
    here text (DEMO VERSION!) is a string with two '\'
    (yas-expand-snippet  text)

    The expaned string is "\*", but "\\*' is expected. The below one will expand to "\\*"
    (setq text "\\\\\\\\*")
    (yas-expand-snippet  text)

    So it looks like if there is two '\' in text, then after expand there will be one. and four to two.
    And one also to one. like below.
    (yas-expand-snippet "\\*")

    Why the above behavior?
    Because '\' is also treated as a special char in snippet by yassnippet. It is used to quote two special chars in the (DEMO VERSION!) snipppet: '$' and '`', to input them literally.


    So there is no bug in the software, instead, you should change your (DEMO VERSION!) snippet. To output a '\' after expandation, you should use '\\' in the snippet.

** run
   - Note taken on [2017-01-06 Fri 21:23]
  
   just run: pns-expand-template-by-name
   (pns-update-template-list will be called inside that function)


   convert the old snippet to new snippet by:
   pns-tool-convert-all
   will convert all files in pcs-snippet-dir, and stored in pns-snippet-dir 

** tools
*** convert snippets in  aspk-code-snippets to aspk-new-snippets format
    given a directory, convert all snippets file under that dir to a single org file. each file is an entry, the headline is the name of that snippet, the src block is the contnet.
    
    Run this code block, then call pns-expand-template-by-name interactively, then all snippets files under pcs-snippet-dir/perl-mode can be selected.
    
    #+NAME: methods
    #+begin_src elisp
    (defun pns-tool-convert-aspk-code-snippets-to-new (dir output-file mode)
      "Convert all snippets(native style) in DIR to a single org mode file OUTPUT-FILE. each file becomes an entry"
      (with-current-buffer (find-file-noselect output-file)
        (erase-buffer))
      (let (name value)
        (mapc (lambda (file)
                ;; (message "file=%s" file)
                (condition-case *error-info*
                    (progn
                      (and (get-buffer " myTemp") (kill-buffer " myTemp"))
                      (set-buffer (get-buffer-create " myTemp"))
                      (insert-file-contents file nil nil nil t))
                  (error
                   (message "Error happened: %S" *error-info*)
                   (debug *error-info*)
                   (list "Error: Fail to get snippet name. Error info below" *error-info*)))

                (goto-char (point-min))
                ;; (re-search-forward "^\s*#\s*name\s*:\s*\\(.*\\)" (point-max))
                (when (re-search-forward "^\s*#\s*name\s*:\s*\\(.*\\)"(point-max) t)
                  (match-string 1)
                  ;; here (match-string 1) is the matched text by first (), add processing codes here
                  (message "Matched string %s" (match-string 1))
                  (setq name (match-string 1))
                  (when (re-search-forward "^\s*#\s*--\s*\n"(point-max) t)
                    (setq value (buffer-substring-no-properties (match-end 0) (point-max))))
                  ;; replace ` with \`
                  (setq value (replace-regexp-in-string "`" "\\`" value t t))
                  (with-current-buffer (find-file-noselect output-file)
                    ;; (erase-buffer)
                    (goto-char (point-max))
                    ;; (insert (format "\n* %s\n#+name:content\n#+begin_src java\n%s\n#+end_src" name value))
                    (insert (format "\n* %s\n#+begin_src %s\n%s\n#+end_src\n" name mode value))
                    (save-buffer)))
                (kill-buffer " myTemp"))
              (f-files dir nil t))))


    ;; test:
    (defun pns-tool-convert-all ()
      (interactive)
      (mapc (lambda (mode)
              (let ((file (expand-file-name (format    "%s/%s-mode/collection_of_old_snippet.org" pns-snippet-dir mode)))
                    (dir (expand-file-name (format "%s/%s-mode" pcs-snippet-dir mode))))
                ;; (when (file-exists-p file)
                ;;   (delete-file file))
                (when (file-exists-p dir)
                  (pns-tool-convert-aspk-code-snippets-to-new dir file mode))))
            pcs--mode-names))

    ;; "/Users/astropeak/Dropbox/project/aspk-new-snippet/snippets/java-mode/file-processing.org"
    ;; (setq pns-template-file "/tmp/aa.org")

    ;; then run pns-expand-template-by-name
    #+end_src
                    
** programming notes
*** 190131 elisp 'string-match' is very buggy, never use it
    (string-match "^\s+" " aaa")
    (match-string 0)
    (match-beginning 0)
    (match-end 0)


    In the above example, the second line will raise an error. 

    But use re-search-forward instead(first insert the string to a temp (DEMO VERSION!) buffer)

*** throw errors guard correctness, detect fault in development stage
    Then when error happens, the program stops at that place, debugging will be much easy.
*** write test for each function
    This helps understand the function. and also a regretion test.
*** use uniform data format. If not the same, first convert to the same
    This will greatly reduce complexsity of codes. 
    
    In this project, the parameter has tow form:
    (key value) and (key (display-value real-value)).
    
    So there are lots of codes that handle the difference of those tow froms.
    
    Good way is: first convert to uniform format before processing.  This applys in many places.
*** input-parser: a program should have a uniform/stable internal format for representing the input data
    Then we can change the original input format easily, just write a new input parser.
    
    In this project, the input data is an org mode file. The internal format is a lists of template.
    We can easily change the input date to a string, or a list, just write a new parser for that data format.
    
    We can name this function as xxx-input-parser, it accepts one type of input data, and always return the internal input format. The xxx-input-parser function call different coolier functions to process input data, based on their type.
*** emacs lisp global variable, and funtion interface design
    the -contains? function from dash package don't add a third parameter, but it use a global variable -compare-fn to used as compare function.
    Since emacs list is dynamic binding, so we can use this idiom to express this without change the global value of '-comare-fn' value:
    #+NAME: no-name
    #+begin_src elisp :results value
    (let ((-compare-fn (lambda (a b) (equal (+ 1 a) b))))
      (-contains? '(1 2 3) 2)
      )
    ;; and here -contains-fn still its original value.
    #+end_src
    
    This teckniques are used common when search regexp:
    #+NAME: no-name
    #+begin_src elisp
    (let* (
           (name "\\(header\\|content\\)")
           (case-fold-search t)  ;; makes the searching ignore case
           (regexp (concat org-babel-src-name-regexp name "[ \t(]*[\r\n]\\(?:^#.*[\r\n]\\)*"
                           (substring org-babel-src-block-regexp 1))))
      (re-search-forward regexp nil t))

    #+end_src
    
    -contains? documents
    #+BEGIN_SRC text
    -contains? (list element)

Return non-nil if list contains element.

The test for equality is done with equal, or with -compare-fn if that's non-nil.

Alias: -contains-p

(-contains? '(1 2 3) 1) ;; => t
(-contains? '(1 2 3) 2) ;; => t
(-contains? '(1 2 3) 4) ;; => nil

    #+END_SRC
*** annotation is a great way for adding syntax to a existing grammer
    I use annotation to add below syntaxs to org mode file grammer:
    1. define variables formally
    2. the if statement
    3. get variable value
       
*** create a unique name for every concepts, things, and there relationships
    This will make programming very clear!!!
    
*** 基础代码要做好，要与上层逻辑代码分离
    这个项目中，在tree的实现上，花费了太多的时间，就是因为将tree的实现与其它逻辑搅在一起了。
    
    最后调用了之前写的tree模块，问题很快得到解决。
    
*** 编程的难点在哪里？
    - 函数、API用错，可能是由于笔误，记忆不清，理解不够等
    - 一直在重复，以前的经验没有用上。
      
    目前通过编写snippet，以上问题都能够得到解决。 
    
*** 感觉emacs的坑太多了。。以及dynamic好处、坏处分析
    很容易出错，并且错误提示很不明显，都不知道到底哪错了。
    还有dynamic scoping也容易出错。如果有个临时变量忘记放在let中，则可能造成非常诡异的问题。或者回调函数中引用了一个全局变量xyz, 并将它传给map.但map中也定义了一个xyz，则此时回调函数中的xyz会绑定到map中的这个，造成问题。 在aspk/tree-iterate中遇到过一例。
    但dynamic scoping也有好处，可以通过全局变量达到传递参数的效果。
    
*** file system is a natual hash table(或者成为程序各个部分的连接点)
    the key is the filename
    value is whatever

    check if a key exists by checking if a file exists
    delete a key by delete a file

    And has persistency natively.
    The drawback is efficiency.

    A great benifet is it aways exists and don't need any other third party tools/packages. And everyone already be very familar to this interface.

    An example is that when scraping all SEC index files, I just store all index html file to filesystem in a scrapy project. Then I can continue process the index html files in a django project to save the extracted info to a database. So that I avoid the trouble of using django orm in a scrapy project(which is not supported by default and seems lots of trouble). And here we can see another good practice of programming: seperate each part and make each mediaet result visible. It helps write codes, debug, and test, and refactor.
    
    对于scrape all sec index html page 中的信息，并保存在mysql中，其中scraping这一块scrapy做的比较好，而将数据保存在mysql中django 的ORM则做的比较好。有两种方案
    1. 协调两个工具，让其工作在一块。不管是在scrapy中调用django，还是在django中调用scrapy.（没有现成的解决方案，需要折腾）
    2. 二者分开工作，但制订一个中间的通信协义。
       
    很明显第二种方案要好。文件系统就是一个非常好的通信媒介。scrapy 将所有的index html file保存file system中，然后在django中读取每个file，解析数据并保存在mysql中。

*** the drawback of framework
    1. You should learn how to use it, because it create many typecal ways of working that you must follow.
    2. If your requirement doesn't supported by default, then it hard to make it work.

    So heavy framework makes doing specific works easy while it is hard to adpat for new requirement.
    Light framework provide more flexiable APIs so that the user can composit them to implement their requrement. But it doesn't provide an  avaliable solution to a specific problem.

    New comers might love a heavy framework, while an experienced man loves a light one.
** old doc(OUTDATED)
   - Note taken on [2019-01-31 Thu 14:56] \\
     Document in this seciotn is outdated, because the design and implementation is total changed.
*** Three main part of the program
    1. get parameters from user by helm or read-string. Done by pns-prompt-for-header.
       The input is pns-templates(now it is a global variable), but only the header part is needed.
       
       What this fucntion done is given a list of headers, let user select parameter values if there are multiple, and finally return one unique header.
       A header can be wrtten in a relative flexible way.
       
       The output is a list of cons of (key . value). The key is variable names in the snippet, the value is its value.
       an example: pns.el:pns-do-expand:157:	header=(("command" . "create-channel") ("for" . "read") ("part" . "part1") ("file-name" . "\"aaa.b\""))
    2. expand a snippet by yas-expand-snippet
       Definition:  a snippet is the content part of a template.
       
       The input is a header.
       pns-templates defines relationship between a header and a snippet. Given a header, there will be one snippet. and the header is the expand-env.
       
       The output or result:
       the snippet inserted on current buffer, current position.
    3. parse a template file, done by pns-main-update
       Definition: a template file is an org file with an entry tree, whose first level entry's headline starated with pns-snippet-entry-regexp. 
       Input is a template file, specified by pns-snippet-file.
       Output is pns-templates
       
       Each entry in a template file may contains two src blocks named 'header' or 'content'.
       All 'header' src blocks from the root entry to any leaf entry(included) forms one header element, the same apllys for 'content' src blocks. And this header and content elements combined.
       
       
    pns-do-expand integrate part 1 and part2.
*** relationship
    |--------+-----------+------------------+---------+-------------------+---------------------------|
    | module | templates | list of template | header  | list of parameter |                           |
    |        |           |                  | content | :string           |                           |
    |        | shortcuts | list of shortcut | name    | :string           |                           |
    |        |           |                  | filter  | list of header    | header with default value |
    |        | name      | :string          |         |                   |                           |
    Note: the table looks unaligned because 'space' is narrow than a letter.
    
    A shortcut is a way to 1: provide default values to parametes in a header, then those parameters will not be prompted. 2: combine many templates.
    
    a shortcut with empty filter let user select all possible template. The name should be "details".
    
    One snippet file is one module, a module's name property is used to selected by helm. then we call pns-main-shortcut.
*** parameter format
    Maybe its better to use struct to express a parameter.
    
    The parameter struct definition. Use struct is it can be extented easily.
    #+NAME: no-name
    #+begin_src elisp
    (defstruct pns-value
      display
      real
      )

    (defstruct pns-parameter
      key 
      values  ;; a list of pns-value
      doc
      default-value
      reference ;; the referenced variabled string name
      not-prompt-p ;; should this parameter not be prompted. in case this in only used as variable referenced by other elements.
      )

    (setq a (make-pns-parameter :key "command" :default-value "aaaaa"))

    (pns-parameter-default-value a)

    #+end_src
    
**** the new parser
     #+NAME: vars-hatch
     #+begin_src elisp
     (setq pns-token-reference "\\$")
     (setq pns-token-default-value "=")
     (setq pns-token-doc "@")
     #+end_src
     
     #+NAME: methods-hatch
     #+begin_src elisp :results output
     (defun pns-parse-parameter (parameter)
       "parse a parameter to the pns-parameter struct. The parameter is read form the snippet file, are a list of symbols"
       ;; a input parameter is in this format:
       ;; 1. (key value)
       ;; 2. (key (display-value real-value) )
       ;; an element may be a symbol, or a string, and there are special elemnt, which start with a special character.
       (let (para elem pp)

         ;; convert all to string
         (setq para
               (mapcar (lambda (element)
                         (cond ((stringp element) (format "\"%s\"" element))
                               ((symbolp element) (format "%s" element))
                               ((listp element)
                                (mapcar (lambda (elem)
                                          (cond ((stringp elem) (format "\"%s\"" elem))
                                                ((symbolp elem) (format "%s" elem))
                                                (t (error "Elem type wrong: %S" elem))))
                                        element)
                                )
                               (t (error "Parameter's element type wrong, only symbol or string accepted: %S" element))))
                       parameter))

         ;; make pns-parameter
         (setq pp (make-pns-parameter))
         (setf (pns-parameter-key pp) (pop para))
         (tracee pp)
         (unless (pns-parameter-key pp)
           (error "Parameter is nil: %S" para))

         (while para
           (setq elem (pop para))
           (tracee elem)
           (cond
            ;; parse values
            ((listp elem)
             (setf (pns-parameter-values pp) (append (list (cons (nth 0 elem) (nth 1 elem))) (pns-parameter-values pp))))

            ;; BUG: if $ not at the begining, still matched.
            ;; parse doc
            ((and (stringp elem) (string-match pns-token-doc elem))
             (setf (pns-parameter-doc pp) (substring elem 1)))

            ;; parse reference
            ((and (stringp elem) (string-match pns-token-reference elem))
             (setf (pns-parameter-reference pp) (substring elem 1)))

            ;; parse default-value
            ((and (stringp elem) (string-match pns-token-default-value elem))
             (setf (pns-parameter-default-value pp) (substring elem 1)))

            (t (message "here")
               (unless (stringp elem) (error "Element is not string: %S" elem))
               (setf (pns-parameter-values pp) (append (list (cons elem elem)) (pns-parameter-values pp))))
            )
           )
         (tracee pp)
         pp))

     (defun pns-parse-header (header)
       (mapcar (lambda (parameter)
                 (pns-parse-parameter parameter))
               header))

     (defun pns-parse-templates (templates)
       (mapcar (lambda (tmpl)
                 (pns-parse-header (pns-assoc 'header tmpl)))
               templates))

     (defun pns-do-xxx ()
       (pns-parse-templates pns-tmp-templates))

     (defun pns-format-parameter (parameter)
       (format " key: %s\n values: %s\n doc: %s\n default-value: %s\n reference: %s\n not-prompt-p: %s\n\n"
               (pns-parameter-key parameter)
               (pns-parameter-values parameter)
               (pns-parameter-doc parameter)
               (pns-parameter-default-value parameter)
               (pns-parameter-reference parameter)
               (pns-parameter-not-prompt-p parameter))
       )

     (message "%S" (mapcar (lambda (header)
                             (mapcar (lambda (parameter)
                                       (pns-format-parameter parameter))
                                     header))
                           (pns-do-xxx)))
     #+end_src
     
     
     this function convert the snippet file's src blocks tree to a the lisp repreent part. The main job is merge 'header' and 'content' src blocks.
     
     #+name: test-input 
     #+BEGIN_SRC org :disabled-tangle /tmp/pns.x.y/1.org :mkdirp yes
     ,* snippet: aaa
       ,#+name: header
       ,#+begin_src elisp
        ((g-file-name "=abc.txt") (g-file-handler =$fh))
       ,#+end_src

       aaaa

     ,** aaaaa
        ,#+name: header
        ,#+begin_src elisp
        ((command open "@open a file") (target file "@not a pipe")
         (for =write (read <) (write >) (append >>) (readwrite +>))
         (file-name $g-file-name) (file-handler $g-file-handler))
        ,#+end_src
        aaa 
        
        ,#+name: content
        ,#+begin_src perl :results output
        open my `file-handler`, `for`, `file-name` or die "Open file failed";
        ,#+end_src
        aaa
     ,** bbbbb
        ,#+name: header
        ,#+begin_src elisp
        ((command close "@close a file") (file-handler $g-file-handler))
        ,#+end_src
        aaaa 
        ,#+name: content
        ,#+begin_src perl :results output
        close `file-handler`;
        ,#+end_src

        aaaa

     #+END_SRC
        
        #+name: test-input
        #+NAME: test-methods for pns-create-templates
        #+begin_src elisp
        (setq snippet-file "/tmp/pns.x.y/1.org")

        (setq pns-tmp-header nil)
        (setq pns-tmp-templates nil)
        (pns-create-templates
         (pns-convert-block-list-to-tree (pns-get-all-src-blocks snippet-file pns-snippet-entry-regexp pns-src-block-name-regexp))
         nil nil)
        ;; the result is in pns-tmp-templates
        (message "%S" pns-tmp-templates)
        #+end_src
        
        #+RESULTS: test-methods
     : (((header (g-file-name "=abc.txt") (g-file-handler =$fh) (command open "@open a file") (target file "@not a pipe") (for =write (read <) (write >) (append >>) (readwrite +>)) (file-name $g-file-name) (file-handler $g-file-handler)) (content . "   open my `file-handler`, `for`, `file-name` or die \"Open file failed\";
     : ")) ((header (g-file-name "=abc.txt") (g-file-handler =$fh) (command close "@close a file") (file-handler $g-file-handler)) (content . "   close `file-handler`;
     : ")))
        
        
        
        
    
